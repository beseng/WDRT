

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>WDRT.ESSC &mdash; WDRT 1.0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
        <link rel="index" title="Index"
              href="../../genindex.html"/>
        <link rel="search" title="Search" href="../../search.html"/>
    <link rel="top" title="WDRT 1.0 documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

   
  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> WDRT
          

          
          </a>

          
            
            
              <div class="version">
                1.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">WDRT</a>
        
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../index.html">Module code</a> &raquo;</li>
        
      <li>WDRT.ESSC</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for WDRT.ESSC</h1><div class="highlight"><pre>
<span></span><span class="c1"># Copyright 2016 Sandia Corporation and the National Renewable Energy</span>
<span class="c1"># Laboratory</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span> <span class="k">as</span> <span class="nn">stats</span>
<span class="kn">import</span> <span class="nn">scipy.optimize</span> <span class="k">as</span> <span class="nn">optim</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span> <span class="k">as</span> <span class="nn">interp</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">from</span> <span class="nn">sklearn.decomposition</span> <span class="k">import</span> <span class="n">PCA</span> <span class="k">as</span> <span class="n">skPCA</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">bs4</span>
<span class="kn">import</span> <span class="nn">urllib2</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="k">import</span> <span class="n">datetime</span><span class="p">,</span> <span class="n">date</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">copy</span>


<div class="viewcode-block" id="EA"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.EA">[docs]</a><span class="k">class</span> <span class="nc">EA</span><span class="p">:</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">():</span>
        <span class="k">return</span>
<div class="viewcode-block" id="EA.getContours"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.EA.getContours">[docs]</a>    <span class="k">def</span> <span class="nf">getContours</span><span class="p">():</span>
        <span class="k">return</span></div>
<div class="viewcode-block" id="EA.getSamples"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.EA.getSamples">[docs]</a>    <span class="k">def</span> <span class="nf">getSamples</span><span class="p">():</span>
        <span class="k">return</span></div>

<div class="viewcode-block" id="EA.saveData"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.EA.saveData">[docs]</a>    <span class="k">def</span> <span class="nf">saveData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileName</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Saves all available data obtained via the EA module to</span>
<span class="sd">        a .h5 file</span>

<span class="sd">        Params</span>
<span class="sd">        ______</span>
<span class="sd">        fileName : string</span>
<span class="sd">            relevent path and filename where the .h5 file will be created and</span>
<span class="sd">            saved</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fileName</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">fileName</span> <span class="o">=</span> <span class="s1">&#39;NDBC&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.h5&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">file_extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">file_extension</span><span class="p">:</span>
                <span class="n">fileName</span> <span class="o">=</span> <span class="n">fileName</span> <span class="o">+</span> <span class="s1">&#39;.h5&#39;</span>
        <span class="k">with</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>

            <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;method&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>
            <span class="n">gp</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;parameters&#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_saveParams</span><span class="p">(</span><span class="n">gp</span><span class="p">)</span>

            <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">_saveData</span><span class="p">(</span><span class="n">fileObj</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>

            <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">grc</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;ReturnContours&#39;</span><span class="p">)</span>
                <span class="n">f_T_Return</span> <span class="o">=</span> <span class="n">grc</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;T_Return&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="p">)</span>
                <span class="n">f_T_Return</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;s&#39;</span>
                <span class="n">f_T_Return</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;contour, energy period&#39;</span>
                <span class="n">f_Hs_Return</span> <span class="o">=</span> <span class="n">grc</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Hs_Return&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">)</span>
                <span class="n">f_Hs_Return</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;m&#39;</span>
                <span class="n">f_Hs_Return</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;contours, significant wave height&#39;</span>

            <span class="c1"># Samples for full sea state long term analysis</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Hs_SampleFSS&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleFSS</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">gfss</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;Samples_FullSeaState&#39;</span><span class="p">)</span>
                <span class="n">f_Hs_SampleFSS</span> <span class="o">=</span> <span class="n">gfss</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Hs_SampleFSS&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleFSS</span><span class="p">)</span>
                <span class="n">f_Hs_SampleFSS</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;m&#39;</span>
                <span class="n">f_Hs_SampleFSS</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;full sea state significant wave height samples&#39;</span>
                <span class="n">f_T_SampleFSS</span> <span class="o">=</span> <span class="n">gfss</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;T_SampleFSS&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">T_SampleFSS</span><span class="p">)</span>
                <span class="n">f_T_SampleFSS</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;s&#39;</span>
                <span class="n">f_T_SampleFSS</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;full sea state energy period samples&#39;</span>
                <span class="n">f_Weight_SampleFSS</span> <span class="o">=</span> <span class="n">gfss</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Weight_SampleFSS&#39;</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Weight_SampleFSS</span><span class="p">)</span>
                <span class="n">f_Weight_SampleFSS</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;full sea state relative weighting samples&#39;</span>

            <span class="c1"># Samples for contour approach long term analysis</span>
            <span class="k">if</span><span class="p">(</span><span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Hs_SampleCA&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleCA</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">gca</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;Samples_ContourApproach&#39;</span><span class="p">)</span>
                <span class="n">f_Hs_sampleCA</span> <span class="o">=</span> <span class="n">gca</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Hs_SampleCA&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleCA</span><span class="p">)</span>
                <span class="n">f_Hs_sampleCA</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;m&#39;</span>
                <span class="n">f_Hs_sampleCA</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;contour approach significant wave height samples&#39;</span>
                <span class="n">f_T_sampleCA</span> <span class="o">=</span> <span class="n">gca</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;T_SampleCA&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">T_SampleCA</span><span class="p">)</span>
                <span class="n">f_T_sampleCA</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;s&#39;</span>
                <span class="n">f_T_sampleCA</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;contour approach energy period samples&#39;</span></div>

<div class="viewcode-block" id="EA.plotData"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.EA.plotData">[docs]</a>    <span class="k">def</span> <span class="nf">plotData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Display a plot of the 100-year return contour, full sea state samples</span>
<span class="sd">        and contour samples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">,</span> <span class="s1">&#39;bo&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;NDBC data&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;100 year contour&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T_SampleFSS</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleFSS</span><span class="p">,</span> <span class="s1">&#39;ro&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;full sea state samples&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T_SampleCA</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleCA</span><span class="p">,</span> <span class="s1">&#39;y^&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;contour approach samples&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="s1">&#39;small&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Energy period, $T_e$ [s]&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Sig. wave height, $H_s$ [m]&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

<div class="viewcode-block" id="EA.getContourPoints"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.EA.getContourPoints">[docs]</a>    <span class="k">def</span> <span class="nf">getContourPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">T_Sample</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get points along a specified environmental contour.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            T_Sample : nparray</span>
<span class="sd">                points for sampling along return contour</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            Hs_SampleCA : nparray</span>
<span class="sd">                points sampled along return contour</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">amin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="p">)</span>
        <span class="n">amax</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="p">)</span>

        <span class="n">w1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">[</span><span class="n">amin</span><span class="p">:</span><span class="n">amax</span><span class="p">]</span>
        <span class="n">w2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">[</span><span class="n">amax</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">[:</span><span class="n">amin</span><span class="p">]))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">w1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">w2</span><span class="p">)):</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="p">[</span><span class="n">amin</span><span class="p">:</span><span class="n">amax</span><span class="p">]</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">[</span><span class="n">amin</span><span class="p">:</span><span class="n">amax</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="p">[</span><span class="n">amax</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="p">[:</span><span class="n">amin</span><span class="p">]))</span>
            <span class="n">y1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">[</span><span class="n">amax</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">[:</span><span class="n">amin</span><span class="p">]))</span>

        <span class="n">ms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">x1</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">x1</span><span class="p">[</span><span class="n">ms</span><span class="p">]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y1</span><span class="p">[</span><span class="n">ms</span><span class="p">]</span>

        <span class="n">si</span> <span class="o">=</span> <span class="n">interp</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="n">Hs_SampleCA</span> <span class="o">=</span> <span class="n">si</span><span class="p">(</span><span class="n">T_Sample</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">T_SampleCA</span> <span class="o">=</span> <span class="n">T_Sample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleCA</span> <span class="o">=</span> <span class="n">Hs_SampleCA</span>
        <span class="k">return</span> <span class="n">Hs_SampleCA</span></div>

<div class="viewcode-block" id="EA.steepness"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.EA.steepness">[docs]</a>    <span class="k">def</span> <span class="nf">steepness</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">SteepMax</span><span class="p">,</span> <span class="n">T_vals</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;This function calculates a steepness curve to be plotted on an H vs. T</span>
<span class="sd">        diagram.  First, the function calculates the wavelength based on the</span>
<span class="sd">        depth and T. The T vector can be the input data vector, or will be</span>
<span class="sd">        created below to cover the span of possible T values.</span>
<span class="sd">        The function solves the dispersion relation for water waves</span>
<span class="sd">        using the Newton-Raphson method. All outputs are solved for exactly</span>
<span class="sd">        using: (w^2*h/g=kh*tanh(khG)</span>
<span class="sd">        Approximations that could be used in place of this code for deep</span>
<span class="sd">        and shallow water, as appropriate:</span>
<span class="sd">        deep water:h/lambda &gt;= 1/2, tanh(kh)~1, lambda = (g.*T.^2)./(2*.pi)</span>
<span class="sd">        shallow water:h/lambda &lt;= 1/20, tanh(kh)~kh, lambda = T.*(g.*h)^0.5</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        depth: float</span>
<span class="sd">            Depth at site</span>
<span class="sd">        SteepMax: float</span>
<span class="sd">            Wave breaking steepness estimate (e.g., 0.07).</span>
<span class="sd">        T_vals :np.array</span>
<span class="sd">            Array of T values [sec] at which to calculate the breaking height.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SteepH: np.array</span>
<span class="sd">            H values [m] that correspond to the T_mesh values creating the</span>
<span class="sd">            steepness curve.</span>
<span class="sd">        T_steep: np.array</span>
<span class="sd">            T values [sec] over which the steepness curve is defined.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>

<span class="sd">        To find limit the steepness of waves on a contour by breaking::</span>
<span class="sd">            import numpy as np</span>
<span class="sd">            import WDRT.ESSC as ESSC</span>

<span class="sd">            # Pull spectral data from NDBC website</span>
<span class="sd">            buoy = ESSC.buoy(46022)</span>
<span class="sd">            buoy.fetchFromWeb()</span>

<span class="sd">            # Declare required parameters</span>
<span class="sd">            depth = 391.4  # Depth at measurement point (m)</span>
<span class="sd">            size_bin = 250.  # Enter chosen bin size</span>

<span class="sd">            # Create Environtmal Analysis object using above parameters</span>
<span class="sd">            ea = ESSC.ea(depth, size_bin, buoy)</span>


<span class="sd">            T_vals = np.arange(0.1, np.amax(buoy46022.T), 0.1)</span>
<span class="sd">            SteepMax = 0.07  # Optional: enter estimate of breaking steepness</span>
<span class="sd">            SteepH = ea.steepness(SteepMax,T_vals)</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># Calculate the wavelength at a given depth at each value of T</span>
        <span class="n">lambdaT</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">g</span> <span class="o">=</span> <span class="mf">9.81</span>  <span class="c1"># [m/s^2]</span>
        <span class="n">omega</span> <span class="o">=</span> <span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="n">T_vals</span><span class="p">)</span>
        <span class="n">lambdaT</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">T_vals</span><span class="p">)):</span>
            <span class="c1"># Initialize kh using Eckert 1952 (mentioned in Holthuijsen pg. 124)</span>
            <span class="n">kh</span> <span class="o">=</span> <span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">depth</span> <span class="o">/</span> \
                <span class="p">(</span><span class="n">g</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">((</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">depth</span> <span class="o">/</span> <span class="n">g</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span><span class="p">))</span>
            <span class="c1"># Find solution using the Newton-Raphson Method</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>
                <span class="n">kh0</span> <span class="o">=</span> <span class="n">kh</span>
                <span class="n">f0</span> <span class="o">=</span> <span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">depth</span> <span class="o">/</span> <span class="n">g</span> <span class="o">-</span> <span class="n">kh0</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">kh0</span><span class="p">)</span>
                <span class="n">df0</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">kh</span><span class="p">)</span> <span class="o">-</span> <span class="n">kh</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">kh</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
                <span class="n">kh</span> <span class="o">=</span> <span class="o">-</span><span class="n">f0</span> <span class="o">/</span> <span class="n">df0</span> <span class="o">+</span> <span class="n">kh0</span>
                <span class="n">f</span> <span class="o">=</span> <span class="p">(</span><span class="n">omega</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">depth</span> <span class="o">/</span> <span class="n">g</span> <span class="o">-</span> <span class="n">kh</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">tanh</span><span class="p">(</span><span class="n">kh</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">f0</span> <span class="o">-</span> <span class="n">f</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mi">6</span><span class="p">):</span>
                    <span class="k">break</span>

            <span class="n">lambdaT</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">kh</span> <span class="o">/</span> <span class="n">depth</span><span class="p">))</span>
            <span class="k">del</span> <span class="n">kh</span><span class="p">,</span> <span class="n">kh0</span>

        <span class="n">lambdaT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">lambdaT</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">SteepH</span> <span class="o">=</span> <span class="n">lambdaT</span> <span class="o">*</span> <span class="n">SteepMax</span>
        <span class="k">return</span> <span class="n">SteepH</span></div>

<div class="viewcode-block" id="EA.bootStrap"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.EA.bootStrap">[docs]</a>    <span class="k">def</span> <span class="nf">bootStrap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">boot_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">plotResults</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Get 95% confidence bounds about a contour using the bootstrap</span>
<span class="sd">        method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            boot_size: int (optional)</span>
<span class="sd">                Number of bootstrap samples that will be used to calculate 95%</span>
<span class="sd">                confidence interval. Should be large enough to calculate stable</span>
<span class="sd">                statistics. If left blank will be set to 1000.</span>
<span class="sd">            plotResults: boolean (optional)</span>
<span class="sd">                Option for showing plot of bootstrap confidence bounds. If left</span>
<span class="sd">                blank will be set to True and plot will be shown.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            contourmean_Hs : nparray</span>
<span class="sd">                Hs values for mean contour calculated as the average over all</span>
<span class="sd">                bootstrap contours.</span>
<span class="sd">            contourmean_T : nparray</span>
<span class="sd">                T values for mean contour calculated as the average over all</span>
<span class="sd">                bootstrap contours.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span>
        <span class="n">Hs_Return_Boot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span><span class="p">,</span><span class="n">boot_size</span><span class="p">])</span>
        <span class="n">T_Return_Boot</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span><span class="p">,</span><span class="n">boot_size</span><span class="p">])</span>
        <span class="n">buoycopy</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="p">);</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">boot_size</span><span class="p">):</span>
            <span class="n">boot_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
            <span class="n">buoycopy</span><span class="o">.</span><span class="n">Hs</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="n">boot_inds</span><span class="p">])</span>
            <span class="n">buoycopy</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">boot_inds</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;PCA&quot;</span><span class="p">:</span>
                <span class="n">essccopy</span> <span class="o">=</span> <span class="n">PCA</span><span class="p">(</span><span class="n">buoycopy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">size_bin</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;GaussianCopula&quot;</span><span class="p">:</span>
                <span class="n">essccopy</span> <span class="o">=</span> <span class="n">GaussianCopula</span><span class="p">(</span><span class="n">buoycopy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;Rosenblatt&quot;</span><span class="p">:</span>
                <span class="n">essccopy</span> <span class="o">=</span> <span class="n">Rosenblatt</span><span class="p">(</span><span class="n">buoycopy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;ClaytonCopula&quot;</span><span class="p">:</span>
                <span class="n">essccopy</span> <span class="o">=</span> <span class="n">ClaytonCopula</span><span class="p">(</span><span class="n">buoycopy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;GumbelCopula&quot;</span><span class="p">:</span>
                <span class="n">essccopy</span> <span class="o">=</span> <span class="n">GumbelCopula</span><span class="p">(</span><span class="n">buoycopy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span><span class="p">)</span>
            <span class="n">Hs_Return_Boot</span><span class="p">[:,</span><span class="n">i</span><span class="p">],</span><span class="n">T_Return_Boot</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">essccopy</span><span class="o">.</span><span class="n">getContours</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">time_ss</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span><span class="p">)</span>

        <span class="n">contour97_5_Hs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">Hs_Return_Boot</span><span class="p">,</span><span class="mf">97.5</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">contour2_5_Hs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">Hs_Return_Boot</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">contourmean_Hs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Hs_Return_Boot</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">contour97_5_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">T_Return_Boot</span><span class="p">,</span><span class="mf">97.5</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">contour2_5_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">T_Return_Boot</span><span class="p">,</span><span class="mf">2.5</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">contourmean_T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">T_Return_Boot</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">contourMean_Hs</span> <span class="o">=</span> <span class="n">contourmean_Hs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">contourMean_T</span> <span class="o">=</span> <span class="n">contourmean_T</span>

        <span class="k">def</span> <span class="nf">plotResults</span><span class="p">():</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">,</span> <span class="s1">&#39;bo&#39;</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;NDBC data&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span><span class="p">,</span> <span class="s1">&#39;k-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;100 year contour&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">contour97_5_T</span><span class="p">,</span> <span class="n">contour97_5_Hs</span><span class="p">,</span> <span class="s1">&#39;r--&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;95% bootstrap confidence interval&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">contour2_5_T</span><span class="p">,</span> <span class="n">contour2_5_Hs</span><span class="p">,</span> <span class="s1">&#39;r--&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">contourmean_T</span><span class="p">,</span> <span class="n">contourmean_Hs</span><span class="p">,</span> <span class="s1">&#39;r-&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Mean bootstrap contour&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;lower right&#39;</span><span class="p">,</span> <span class="n">fontsize</span><span class="o">=</span><span class="s1">&#39;small&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Energy period, $T_e$ [s]&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Sig. wave height, $H_s$ [m]&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">plotResults</span><span class="p">:</span>
            <span class="n">plotResults</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">contourmean_Hs</span><span class="p">,</span> <span class="n">contourmean_T</span></div>

    <span class="k">def</span> <span class="nf">__getCopulaParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">n_size</span><span class="p">,</span><span class="n">bin_1_limit</span><span class="p">,</span><span class="n">bin_step</span><span class="p">):</span>
        <span class="n">sorted_idx</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)),</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="n">x</span><span class="p">])</span>
        <span class="n">Hs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">[</span><span class="n">sorted_idx</span><span class="p">]</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">[</span><span class="n">sorted_idx</span><span class="p">]</span>

        <span class="c1"># Estimate parameters for Weibull distribution for component 1 (Hs) using MLE</span>
        <span class="c1"># Estimate parameters for Lognormal distribution for component 2 (T) using MLE</span>
        <span class="n">para_dist_1</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">exponweib</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span><span class="n">floc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">fa</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">para_dist_2</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">T</span><span class="p">))</span>

        <span class="c1"># Binning</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span><span class="nb">sum</span><span class="p">(</span><span class="n">Hs_val</span> <span class="o">&lt;=</span> <span class="n">bin_1_limit</span> <span class="k">for</span> <span class="n">Hs_val</span> <span class="ow">in</span> <span class="n">Hs</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">200</span><span class="p">):</span>
            <span class="n">bin_i_limit</span> <span class="o">=</span> <span class="n">bin_1_limit</span><span class="o">+</span><span class="n">bin_step</span><span class="o">*</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ind</span><span class="p">,</span><span class="nb">sum</span><span class="p">(</span><span class="n">Hs_val</span> <span class="o">&lt;=</span> <span class="n">bin_i_limit</span> <span class="k">for</span> <span class="n">Hs_val</span> <span class="ow">in</span> <span class="n">Hs</span><span class="p">))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">n_size</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="c1"># Parameters for conditional distribution of T|Hs for each bin</span>
        <span class="n">num</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span> <span class="c1"># num+1: number of bins</span>
        <span class="n">para_dist_cond</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hss</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">para_dist_cond</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">]))])))</span>  <span class="c1"># parameters for first bin</span>
        <span class="n">hss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Hs</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">)]))</span> <span class="c1"># mean of Hs (component 1 for first bin)</span>
        <span class="n">para_dist_cond</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">]))])))</span> <span class="c1"># parameters for second bin</span>
        <span class="n">hss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Hs</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">)]))</span> <span class="c1"># mean of Hs (component 1 for second bin)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">num</span><span class="p">):</span>
            <span class="n">para_dist_cond</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]))])));</span>
            <span class="n">hss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Hs</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">i</span><span class="p">]))]))</span>

        <span class="c1"># Estimate coefficient using least square solution (mean: third order, sigma: 2nd order)</span>
        <span class="n">para_dist_cond</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">T</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">num</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Hs</span><span class="p">)))])));</span>  <span class="c1"># parameters for last bin</span>
        <span class="n">hss</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Hs</span><span class="p">[</span><span class="nb">range</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">ind</span><span class="p">[</span><span class="n">num</span><span class="o">-</span><span class="mi">2</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Hs</span><span class="p">)))]))</span> <span class="c1"># mean of Hs (component 1 for last bin)</span>

        <span class="n">para_dist_cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">para_dist_cond</span><span class="p">)</span>
        <span class="n">hss</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">hss</span><span class="p">)</span>

        <span class="n">phi_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">hss</span><span class="p">[:],</span><span class="n">hss</span><span class="p">[:]</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">hss</span><span class="p">[:]</span><span class="o">**</span><span class="mi">3</span><span class="p">))</span>
        <span class="n">phi_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">column_stack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">num</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span><span class="n">hss</span><span class="p">[:],</span><span class="n">hss</span><span class="p">[:]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

        <span class="c1"># Estimate coefficients of mean of Ln(T|Hs)(vector 4x1) (cubic in Hs)</span>
        <span class="n">mean_cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">phi_mean</span><span class="p">,</span><span class="n">para_dist_cond</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Estimate coefficients of standard deviation of Ln(T|Hs) (vector 3x1) (quadratic in Hs)</span>
        <span class="n">std_cond</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">phi_std</span><span class="p">,</span><span class="n">para_dist_cond</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">para_dist_1</span><span class="p">,</span> <span class="n">para_dist_2</span><span class="p">,</span> <span class="n">mean_cond</span><span class="p">,</span> <span class="n">std_cond</span></div>


<div class="viewcode-block" id="PCA"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.PCA">[docs]</a><span class="k">class</span> <span class="nc">PCA</span><span class="p">(</span><span class="n">EA</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buoy</span><span class="p">,</span> <span class="n">size_bin</span><span class="o">=</span><span class="mf">250.</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">            size_bin : float</span>
<span class="sd">                chosen bin size</span>
<span class="sd">            buoy : NDBCData</span>
<span class="sd">                ESSC.Buoy Object</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;Principle component analysis&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span> <span class="o">=</span> <span class="n">buoy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size_bin</span> <span class="o">=</span> <span class="n">size_bin</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleCA</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleFSS</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_SampleCA</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_SampleFSS</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Weight_points</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp1_params</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigma_param</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generateParams</span><span class="p">(</span><span class="n">size_bin</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__generateParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size_bin</span><span class="o">=</span><span class="mf">250.0</span><span class="p">):</span>
        <span class="n">pca</span> <span class="o">=</span> <span class="n">skPCA</span><span class="p">(</span><span class="n">n_components</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">pca</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)))</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pca</span><span class="o">.</span><span class="n">components_</span><span class="p">)</span>  <span class="c1"># Apply correct/expected sign convention</span>
        <span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="o">*</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>  <span class="c1"># Apply correct/expected sign convention</span>

        <span class="n">Comp1_Comp2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>

        <span class="n">shift</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">Comp1_Comp2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> <span class="mf">0.1</span>  <span class="c1"># Calculate shift</span>


        <span class="n">shift</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">Comp1_Comp2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span> <span class="o">+</span> <span class="mf">0.1</span>  <span class="c1"># Calculate shift</span>
        <span class="c1"># Apply shift to Component 2 to make all values positive</span>
        <span class="n">Comp1_Comp2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Comp1_Comp2</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">shift</span>

        <span class="n">Comp1_Comp2_sort</span> <span class="o">=</span> <span class="n">Comp1_Comp2</span><span class="p">[</span><span class="n">Comp1_Comp2</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">argsort</span><span class="p">(),</span> <span class="p">:]</span>

        <span class="c1"># Fitting distribution of component 1</span>
        <span class="n">comp1_params</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">invgauss</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Comp1_Comp2_sort</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">floc</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">n_data</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span>  <span class="c1"># Number of observations</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">size_bin</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">n_data</span> <span class="o">/</span> <span class="n">size_bin</span><span class="p">),</span>
                         <span class="n">size_bin</span><span class="p">),</span> <span class="n">n_data</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">ranks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">n_data</span><span class="p">)</span>
        <span class="n">hist_count</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">ranks</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">edges</span><span class="p">)</span>
        <span class="n">bin_inds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">ranks</span><span class="p">,</span> <span class="n">bins</span><span class="o">=</span><span class="n">edges</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">Comp2_bins_params</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">bin_inds</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">Comp1_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span>

        <span class="k">for</span> <span class="n">bin_loop</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">bin_inds</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">mask_bins</span> <span class="o">=</span> <span class="n">bin_inds</span> <span class="o">==</span> <span class="n">bin_loop</span>  <span class="c1"># Find location of bin values</span>
            <span class="n">Comp2_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">Comp1_Comp2_sort</span><span class="p">[</span><span class="n">mask_bins</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">Comp1_mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Comp1_mean</span><span class="p">,</span>
                                   <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">Comp1_Comp2_sort</span><span class="p">[</span><span class="n">mask_bins</span><span class="p">,</span> <span class="mi">0</span><span class="p">]))</span>
            <span class="c1"># Calcualte normal distribution parameters for C2 in each bin</span>
            <span class="n">Comp2_bins_params</span><span class="p">[:,</span> <span class="n">bin_loop</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">Comp2_bin</span><span class="p">))</span>

        <span class="n">mu_param</span><span class="p">,</span> <span class="n">pcov</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">curve_fit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__mu_fcn</span><span class="p">,</span>
                                                 <span class="n">Comp1_mean</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">Comp2_bins_params</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:])</span>

        <span class="n">sigma_param</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sigma_fits</span><span class="p">(</span><span class="n">Comp1_mean</span><span class="p">,</span> <span class="n">Comp2_bins_params</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:])</span>

        <span class="k">return</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">shift</span><span class="p">,</span> <span class="n">comp1_params</span><span class="p">,</span> <span class="n">sigma_param</span><span class="p">,</span> <span class="n">mu_param</span>

    <span class="k">def</span> <span class="nf">_saveParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groupObj</span><span class="p">):</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;nb_steps&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;time_r&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_r</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;time_ss&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">time_ss</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;coeff&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;shift&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;comp1_params&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comp1_params</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;sigma_param&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_param</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;mu_param&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mu_param</span><span class="p">)</span>

<div class="viewcode-block" id="PCA.getContours"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.PCA.getContours">[docs]</a>    <span class="k">def</span> <span class="nf">getContours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_ss</span><span class="p">,</span> <span class="n">time_r</span><span class="p">,</span> <span class="n">nb_steps</span><span class="o">=</span><span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;WDRT Extreme Sea State PCA Contour function</span>
<span class="sd">        This function calculates environmental contours of extreme sea states using</span>
<span class="sd">        principal component analysis and the inverse first-order reliability</span>
<span class="sd">        method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">        time_ss : float</span>
<span class="sd">            Sea state duration (hours) of measurements in input.</span>
<span class="sd">        time_r : np.array</span>
<span class="sd">            Desired return period (years) for calculation of environmental</span>
<span class="sd">            contour, can be a scalar or a vector.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space used for</span>
<span class="sd">            inverse FORM calculation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Hs_Return : np.array</span>
<span class="sd">            Calculated Hs values along the contour boundary following</span>
<span class="sd">            return to original input orientation.</span>
<span class="sd">        T_Return : np.array</span>
<span class="sd">           Calculated T values along the contour boundary following</span>
<span class="sd">           return to original input orientation.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To obtain the contours for a NDBC buoy::</span>
<span class="sd">            import numpy as np</span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            # Pull spectral data from NDBC website</span>
<span class="sd">            buoy = ESSC.buoy(&#39;46022&#39;)</span>
<span class="sd">            buoy.fetchFromWeb()</span>

<span class="sd">            # Declare required parameters</span>
<span class="sd">            depth = 391.4  # Depth at measurement point (m)</span>
<span class="sd">            size_bin = 250.  # Enter chosen bin size</span>

<span class="sd">            # Create Environtmal Analysis object using above parameters</span>
<span class="sd">            pca46022 = ESSC.PCA(depth, buoy, size_bin)</span>

<span class="sd">            # used for inverse FORM calculation</span>
<span class="sd">            Time_SS = 1.  # Sea state duration (hrs)</span>
<span class="sd">            Time_r = np.array([100])  # Return periods (yrs) of interest</span>

<span class="sd">            nb_steps = 1000.  # Enter discretization of the circle in the normal space</span>

<span class="sd">            # Contour generation example</span>
<span class="sd">            Hs_Return, T_Return = pca46022.getContours(Time_SS, Time_r, nb_steps)</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">time_ss</span> <span class="o">=</span> <span class="n">time_ss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_r</span> <span class="o">=</span> <span class="n">time_r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span> <span class="o">=</span> <span class="n">nb_steps</span>

        <span class="c1"># IFORM</span>
        <span class="c1"># Failure probability for the desired return period (time_R) given the</span>
        <span class="c1"># duration of the measurements (time_ss)</span>
        <span class="n">p_f</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">365</span> <span class="o">*</span> <span class="p">(</span><span class="mi">24</span> <span class="o">/</span> <span class="n">time_ss</span><span class="p">)</span> <span class="o">*</span> <span class="n">time_r</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_f</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Reliability</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="n">nb_steps</span><span class="p">)</span>
        <span class="c1"># Vary U1, U2 along circle sqrt(U1^2+U2^2)=beta</span>
        <span class="n">U1</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">U2</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="c1"># Calculate C1 values along the contour</span>
        <span class="n">Comp1_R</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">invgauss</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                     <span class="n">mu</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp1_params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                     <span class="n">scale</span><span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp1_params</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="c1"># Calculate mu values at each point on the circle</span>
        <span class="n">mu_R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__mu_fcn</span><span class="p">(</span><span class="n">Comp1_R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_param</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_param</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Calculate sigma values at each point on the circle</span>
        <span class="n">sigma_R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sigma_fcn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_param</span><span class="p">,</span> <span class="n">Comp1_R</span><span class="p">)</span>
        <span class="c1"># Use calculated mu and sigma values to calculate C2 along the contour</span>
        <span class="n">Comp2_R</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                 <span class="n">loc</span><span class="o">=</span><span class="n">mu_R</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma_R</span><span class="p">)</span>

        <span class="c1"># Calculate Hs and T along the contour</span>
        <span class="n">Hs_Return</span><span class="p">,</span> <span class="n">T_Return</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__princomp_inv</span><span class="p">(</span><span class="n">Comp1_R</span><span class="p">,</span> <span class="n">Comp2_R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span>
        <span class="n">Hs_Return</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Hs_Return</span><span class="p">)</span>  <span class="c1"># Remove negative values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="n">Hs_Return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="n">T_Return</span>
        <span class="k">return</span> <span class="n">Hs_Return</span><span class="p">,</span> <span class="n">T_Return</span></div>

<div class="viewcode-block" id="PCA.getSamples"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.PCA.getSamples">[docs]</a>    <span class="k">def</span> <span class="nf">getSamples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_contour_points</span><span class="p">,</span> <span class="n">contour_returns</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;WDRT Extreme Sea State Contour Sampling function</span>
<span class="sd">        This function calculates samples of Hs and T using the EA function to</span>
<span class="sd">        sample between contours of user-defined return periods.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        num_contour_points : int</span>
<span class="sd">            Number of sample points to be calculated per contour interval.</span>
<span class="sd">        contour_returns: np.array</span>
<span class="sd">            Vector of return periods that define the contour intervals in</span>
<span class="sd">            which samples will be taken. Values must be greater than zero and</span>
<span class="sd">            must be in increasing order.</span>
<span class="sd">        random_seed: int (optional)</span>
<span class="sd">            Random seed for sample generation, required for sample</span>
<span class="sd">            repeatability. If left blank, a seed will automatically be</span>
<span class="sd">            generated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Hs_Samples: np.array</span>
<span class="sd">            Vector of Hs values for each sample point.</span>
<span class="sd">        Te_Samples: np.array</span>
<span class="sd">            Vector of Te values for each sample point.</span>
<span class="sd">        Weight_points: np.array</span>
<span class="sd">            Vector of probabilistic weights for each sampling point</span>
<span class="sd">            to be used in risk calculations.</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To get weighted samples from a set of contours::</span>

<span class="sd">            import numpy as np</span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            # Load data from existing text files</span>
<span class="sd">            buoy = ESSC.Buoy(46022)</span>
<span class="sd">            buoy.loadFromText()</span>

<span class="sd">            depth = float(675) # Depth at measurement point (m)</span>
<span class="sd">            size_bin = float(250) # Enter chosen bin size</span>
<span class="sd">            nb_steps = float(1000) # Enter discretization of the circle in the</span>

<span class="sd">            # normal space. Used for inverse FORM calculation.</span>
<span class="sd">            Time_SS = float(1) # Sea state duration (hrs)</span>
<span class="sd">            Time_r = np.array([100]) # Return periods (yrs) of interest</span>
<span class="sd">            num_contour_points = 10 # Number of points to be sampled for each</span>

<span class="sd">            # contour interval.</span>
<span class="sd">            contour_returns = np.array([0.001,0.01,0.05,0.1,0.5,1,5,10,50,100])</span>

<span class="sd">            # Probabilities defining sampling contour bounds.</span>
<span class="sd">            random_seed = 2 # Random seed for sample generation</span>
<span class="sd">            Hs_Sample,T_Sample,Weight_points = EA.getSamples(nb_steps,</span>
<span class="sd">            Time_SS,Time_r)</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># Calculate line where Hs = 0 to avoid sampling Hs in negative space</span>
        <span class="n">Te_zeroline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">2.5</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="n">Te_zeroline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">Te_zeroline</span><span class="p">)</span>
        <span class="n">Hs_zeroline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Te_zeroline</span><span class="p">))</span>

        <span class="c1"># Transform zero line into principal component space</span>
        <span class="n">Comp_zeroline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">([</span><span class="n">Hs_zeroline</span><span class="p">,</span> <span class="n">Te_zeroline</span><span class="p">])),</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">)</span>
        <span class="n">Comp_zeroline</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">Comp_zeroline</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span>

        <span class="c1"># Find quantiles along zero line</span>
        <span class="n">C1_zeroline_prob</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">invgauss</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">Comp_zeroline</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span>
                                              <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp1_params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                              <span class="n">scale</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comp1_params</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">mu_zeroline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__mu_fcn</span><span class="p">(</span><span class="n">Comp_zeroline</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_param</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_param</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">sigma_zeroline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sigma_fcn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_param</span><span class="p">,</span> <span class="n">Comp_zeroline</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">C2_zeroline_prob</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">Comp_zeroline</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span>
                                          <span class="n">loc</span><span class="o">=</span><span class="n">mu_zeroline</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma_zeroline</span><span class="p">)</span>
        <span class="n">C1_normzeroline</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">C1_zeroline_prob</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">C2_normzeroline</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">C2_zeroline_prob</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">contour_probs</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">365</span> <span class="o">*</span> <span class="p">(</span><span class="mi">24</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">time_ss</span><span class="p">)</span> <span class="o">*</span> <span class="n">contour_returns</span><span class="p">)</span>
        <span class="c1"># Reliability contour generation</span>
        <span class="n">beta_lines</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span>
            <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">contour_probs</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># Calculate reliability</span>
        <span class="n">beta_lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">beta_lines</span><span class="p">))</span>  <span class="c1"># Add zero as lower bound to first</span>
        <span class="c1"># contour</span>
        <span class="n">theta_lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>  <span class="c1"># Discretize the circle</span>

        <span class="n">contour_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">contour_probs</span><span class="p">))</span>  <span class="c1"># Add probablity of 1 to the</span>
        <span class="c1"># reliability set, corresponding to probability of the center point of the</span>
        <span class="c1"># normal space</span>

        <span class="c1"># Vary U1,U2 along circle sqrt(U1^2+U2^2) = beta</span>
        <span class="n">U1_lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta_lines</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]),</span> <span class="n">beta_lines</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>
        <span class="n">U2_lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta_lines</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]),</span> <span class="n">beta_lines</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span>

        <span class="c1"># Removing values on the H_s = 0 line that are far from the circles in the</span>
        <span class="c1"># normal space that will be evaluated to speed up calculations</span>
        <span class="n">minval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">U1_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mf">0.5</span>
        <span class="n">mask</span> <span class="o">=</span> <span class="n">C1_normzeroline</span> <span class="o">&gt;</span> <span class="n">minval</span>
        <span class="n">C1_normzeroline</span> <span class="o">=</span> <span class="n">C1_normzeroline</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>
        <span class="n">C2_normzeroline</span> <span class="o">=</span> <span class="n">C2_normzeroline</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

        <span class="c1"># Transform to polar coordinates</span>
        <span class="n">Theta_zeroline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">C2_normzeroline</span><span class="p">,</span> <span class="n">C1_normzeroline</span><span class="p">)</span>
        <span class="n">Rho_zeroline</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">C1_normzeroline</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">C2_normzeroline</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">Theta_zeroline</span><span class="p">[</span><span class="n">Theta_zeroline</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Theta_zeroline</span><span class="p">[</span>
            <span class="n">Theta_zeroline</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>


        <span class="n">Sample_alpha</span><span class="p">,</span> <span class="n">Sample_beta</span><span class="p">,</span> <span class="n">Weight_points</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__generateData</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">,</span>
            <span class="n">Rho_zeroline</span><span class="p">,</span> <span class="n">Theta_zeroline</span><span class="p">,</span> <span class="n">num_contour_points</span><span class="p">,</span><span class="n">contour_probs</span><span class="p">,</span><span class="n">random_seed</span><span class="p">)</span>

        <span class="n">Hs_Sample</span><span class="p">,</span> <span class="n">T_Sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__transformSamples</span><span class="p">(</span><span class="n">Sample_alpha</span><span class="p">,</span> <span class="n">Sample_beta</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_SampleFSS</span> <span class="o">=</span> <span class="n">Hs_Sample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_SampleFSS</span> <span class="o">=</span> <span class="n">T_Sample</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Weight_SampleFSS</span> <span class="o">=</span> <span class="n">Weight_points</span>

        <span class="k">return</span> <span class="n">Hs_Sample</span><span class="p">,</span> <span class="n">T_Sample</span><span class="p">,</span> <span class="n">Weight_points</span></div>

    <span class="k">def</span> <span class="nf">__generateData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">beta_lines</span><span class="p">,</span> <span class="n">Rho_zeroline</span><span class="p">,</span> <span class="n">Theta_zeroline</span><span class="p">,</span> <span class="n">num_contour_points</span><span class="p">,</span> <span class="n">contour_probs</span><span class="p">,</span> <span class="n">random_seed</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates radius, angle, and weight for each sample point</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="n">random_seed</span><span class="p">)</span>

        <span class="n">num_samples</span> <span class="o">=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_contour_points</span>
        <span class="n">Alpha_bounds</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">Angular_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">Angular_ratio</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">Alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_contour_points</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">Weight</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">Sample_beta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="n">Sample_alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>
        <span class="n">Weight_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">beta_lines</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># Loop over contour intervals</span>
            <span class="c1"># Check if any of the radii for the</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">Rho_zeroline</span> <span class="o">-</span> <span class="n">beta_lines</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Hs=0, line are smaller than the radii of the contour, meaning</span>
            <span class="c1"># that these lines intersect</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">):</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.01</span><span class="p">))</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.01</span><span class="p">))</span>
                <span class="n">Alpha_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Theta_zeroline</span><span class="p">[</span><span class="n">left</span><span class="p">],</span> <span class="n">Theta_zeroline</span><span class="p">[</span><span class="n">right</span><span class="p">]</span> <span class="o">-</span>
                                      <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>  <span class="c1"># Save sampling bounds</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Alpha_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
                            <span class="c1"># Find the angular distance that will be covered by sampling the disc</span>
            <span class="n">Angular_dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Alpha_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="c1"># Calculate ratio of area covered for each contour</span>
            <span class="n">Angular_ratio</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">Angular_dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
            <span class="c1"># Discretize the remaining portion of the disc into 10 equally spaced</span>
            <span class="c1"># areas to be sampled</span>
            <span class="n">Alpha</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">Alpha_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
                                    <span class="nb">max</span><span class="p">(</span><span class="n">Alpha_bounds</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">Angular_dist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">num_contour_points</span><span class="p">)</span>
            <span class="c1"># Calculate the weight of each point sampled per contour</span>
            <span class="n">Weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">((</span><span class="n">contour_probs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">contour_probs</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">*</span>
                         <span class="n">Angular_ratio</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">num_contour_points</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_contour_points</span><span class="p">):</span>
                <span class="c1"># Generate sample radius by adding a randomly sampled distance to</span>
                <span class="c1"># the &#39;disc&#39; lower bound</span>
                <span class="n">Sample_beta</span><span class="p">[(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_contour_points</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">beta_lines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span>
                                                             <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">beta_lines</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">beta_lines</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
                <span class="c1"># Generate sample angle by adding a randomly sampled distance to</span>
                <span class="c1"># the lower bound of the angle defining a discrete portion of the</span>
                <span class="c1"># &#39;disc&#39;</span>
                <span class="n">Sample_alpha</span><span class="p">[(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_contour_points</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Alpha</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">+</span>
                                                              <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random_sample</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span><span class="n">Alpha</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">Alpha</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span>
                <span class="c1"># Save the weight for each sample point</span>
                <span class="n">Weight_points</span><span class="p">[(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_contour_points</span> <span class="o">+</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">Weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">Sample_alpha</span><span class="p">,</span> <span class="n">Sample_beta</span><span class="p">,</span> <span class="n">Weight_points</span>

    <span class="k">def</span> <span class="nf">__transformSamples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Sample_alpha</span><span class="p">,</span> <span class="n">Sample_beta</span><span class="p">):</span>
        <span class="n">Sample_U1</span> <span class="o">=</span> <span class="n">Sample_beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">Sample_alpha</span><span class="p">)</span>
        <span class="n">Sample_U2</span> <span class="o">=</span> <span class="n">Sample_beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">Sample_alpha</span><span class="p">)</span>

        <span class="c1"># Sample transformation to principal component space</span>
        <span class="n">Comp1_sample</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">invgauss</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">Sample_U1</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                          <span class="n">mu</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comp1_params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                                          <span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">comp1_params</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">mu_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__mu_fcn</span><span class="p">(</span><span class="n">Comp1_sample</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_param</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu_param</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Calculate sigma values at each point on the circle</span>
        <span class="n">sigma_sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__sigma_fcn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sigma_param</span><span class="p">,</span> <span class="n">Comp1_sample</span><span class="p">)</span>
        <span class="c1"># Use calculated mu and sigma values to calculate C2 along the contour</span>
        <span class="n">Comp2_sample</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">Sample_U2</span><span class="p">,</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
                                      <span class="n">loc</span><span class="o">=</span><span class="n">mu_sample</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">sigma_sample</span><span class="p">)</span>
        <span class="c1"># Sample transformation into Hs-T space</span>
        <span class="n">Hs_Sample</span><span class="p">,</span> <span class="n">T_Sample</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__princomp_inv</span><span class="p">(</span>
            <span class="n">Comp1_sample</span><span class="p">,</span> <span class="n">Comp2_sample</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Hs_Sample</span><span class="p">,</span> <span class="n">T_Sample</span>


    <span class="k">def</span> <span class="nf">__mu_fcn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mu_p_1</span><span class="p">,</span> <span class="n">mu_p_2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Linear fitting function for the mean(mu) of Component 2 normal</span>
<span class="sd">        distribution as a function of the Component 1 mean for each bin.</span>
<span class="sd">        Used in the EA and getSamples functions.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mu_p: np.array</span>
<span class="sd">               Array of mu fitting function parameters.</span>
<span class="sd">        x: np.array</span>
<span class="sd">           Array of values (Component 1 mean for each bin) at which to evaluate</span>
<span class="sd">           the mu fitting function.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        mu_fit: np.array</span>
<span class="sd">                Array of fitted mu values.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">mu_fit</span> <span class="o">=</span> <span class="n">mu_p_1</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">mu_p_2</span>
        <span class="k">return</span> <span class="n">mu_fit</span>


    <span class="k">def</span> <span class="nf">__sigma_fcn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">sig_p</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Quadratic fitting formula for the standard deviation(sigma) of Component</span>
<span class="sd">        2 normal distribution as a function of the Component 1 mean for each bin.</span>
<span class="sd">        Used in the EA and getSamples functions.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sig_p: np.array</span>
<span class="sd">               Array of sigma fitting function parameters.</span>
<span class="sd">        x: np.array</span>
<span class="sd">           Array of values (Component 1 mean for each bin) at which to evaluate</span>
<span class="sd">           the sigma fitting function.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sigma_fit: np.array</span>
<span class="sd">                   Array of fitted sigma values.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">sigma_fit</span> <span class="o">=</span> <span class="n">sig_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">sig_p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">sig_p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">sigma_fit</span>


    <span class="k">def</span> <span class="nf">__princomp_inv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">princip_data1</span><span class="p">,</span> <span class="n">princip_data2</span><span class="p">,</span> <span class="n">coeff</span><span class="p">,</span> <span class="n">shift</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Takes the inverse of the principal component rotation given data,</span>
<span class="sd">        coefficients, and shift. Used in the EA and getSamples functions.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        princip_data1: np.array</span>
<span class="sd">                       Array of Component 1 values.</span>
<span class="sd">        princip_data2: np.array</span>
<span class="sd">                       Array of Component 2 values.</span>
<span class="sd">        coeff: np.array</span>
<span class="sd">               Array of principal component coefficients.</span>
<span class="sd">        shift: float</span>
<span class="sd">               Shift applied to Component 2 to make all values positive.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        original1: np.array</span>
<span class="sd">                   Hs values following rotation from principal component space.</span>
<span class="sd">        original2: np.array</span>
<span class="sd">                   T values following rotation from principal component space.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">original1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">princip_data1</span><span class="p">))</span>
        <span class="n">original2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">princip_data1</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">princip_data2</span><span class="p">)):</span>
            <span class="n">original1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(((</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">princip_data2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">shift</span><span class="p">))</span> <span class="o">+</span>
                             <span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">princip_data1</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="o">/</span> <span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                                                                  <span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">original2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(((</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">princip_data1</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span>
                             <span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">princip_data2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span>
                                             <span class="n">shift</span><span class="p">)))</span> <span class="o">/</span> <span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">original1</span><span class="p">,</span> <span class="n">original2</span>

    <span class="k">def</span> <span class="nf">__betafcn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig_p</span><span class="p">,</span> <span class="n">rho</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Penalty calculation for sigma parameter fitting function to impose</span>
<span class="sd">        positive value constraint.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sig_p: np.array</span>
<span class="sd">               Array of sigma fitting function parameters.</span>
<span class="sd">        rho: float</span>
<span class="sd">             Penalty function variable that drives the solution towards</span>
<span class="sd">             required constraint.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Beta1: float</span>
<span class="sd">               Penalty function variable that applies the constraint requiring</span>
<span class="sd">               the y-intercept of the sigma fitting function to be greater than</span>
<span class="sd">               or equal to 0.</span>
<span class="sd">        Beta2: float</span>
<span class="sd">               Penalty function variable that applies the constraint requiring</span>
<span class="sd">               the minimum of the sigma fitting function to be greater than or</span>
<span class="sd">               equal to 0.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="o">-</span><span class="n">sig_p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Beta1</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Beta1</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="k">if</span> <span class="o">-</span><span class="n">sig_p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">sig_p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">sig_p</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">Beta2</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Beta2</span> <span class="o">=</span> <span class="n">rho</span>
        <span class="k">return</span> <span class="n">Beta1</span><span class="p">,</span> <span class="n">Beta2</span>

    <span class="c1"># Sigma function sigma_fcn defined outside of EA function</span>

    <span class="k">def</span> <span class="nf">__objfun</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig_p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y_actual</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Sum of least square error objective function used in sigma</span>
<span class="sd">        minimization.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sig_p: np.array</span>
<span class="sd">               Array of sigma fitting function parameters.</span>
<span class="sd">        x: np.array</span>
<span class="sd">           Array of values (Component 1 mean for each bin) at which to evaluate</span>
<span class="sd">           the sigma fitting function.</span>
<span class="sd">        y_actual: np.array</span>
<span class="sd">                  Array of actual sigma values for each bin to use in least</span>
<span class="sd">                  square error calculation with fitted values.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        obj_fun_result: float</span>
<span class="sd">                        Sum of least square error objective function for fitted</span>
<span class="sd">                        and actual values.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">obj_fun_result</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">__sigma_fcn</span><span class="p">(</span><span class="n">sig_p</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span> <span class="o">-</span> <span class="n">y_actual</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj_fun_result</span>  <span class="c1"># Sum of least square error</span>

    <span class="k">def</span> <span class="nf">__objfun_penalty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sig_p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y_actual</span><span class="p">,</span> <span class="n">Beta1</span><span class="p">,</span> <span class="n">Beta2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Penalty function used for sigma function constrained optimization.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sig_p: np.array</span>
<span class="sd">               Array of sigma fitting function parameters.</span>
<span class="sd">        x: np.array</span>
<span class="sd">           Array of values (Component 1 mean for each bin) at which to evaluate</span>
<span class="sd">           the sigma fitting function.</span>
<span class="sd">        y_actual: np.array</span>
<span class="sd">                  Array of actual sigma values for each bin to use in least</span>
<span class="sd">                  square error calculation with fitted values.</span>
<span class="sd">        Beta1: float</span>
<span class="sd">               Penalty function variable that applies the constraint requiring</span>
<span class="sd">               the y-intercept of the sigma fitting function to be greater than</span>
<span class="sd">               or equal to 0.</span>
<span class="sd">        Beta2: float</span>
<span class="sd">               Penalty function variable that applies the constraint requiring</span>
<span class="sd">               the minimum of the sigma fitting function to be greater than or</span>
<span class="sd">               equal to 0.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        penalty_fcn: float</span>
<span class="sd">                     Objective function result with constraint penalties</span>
<span class="sd">                     applied for out of bound solutions.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">penalty_fcn</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__objfun</span><span class="p">(</span><span class="n">sig_p</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y_actual</span><span class="p">)</span> <span class="o">+</span> <span class="n">Beta1</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">sig_p</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span>
                       <span class="n">Beta2</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="n">sig_p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="n">sig_p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">sig_p</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">penalty_fcn</span>

    <span class="k">def</span> <span class="nf">__sigma_fits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Comp1_mean</span><span class="p">,</span> <span class="n">sigma_vals</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Sigma parameter fitting function using penalty optimization.</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Comp1_mean: np.array</span>
<span class="sd">                    Mean value of Component 1 for each bin of Component 2.</span>
<span class="sd">        sigma_vals: np.array</span>
<span class="sd">                    Value of Component 2 sigma for each bin derived from normal</span>
<span class="sd">                    distribution fit.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sig_final: np.array</span>
<span class="sd">                   Final sigma parameter values after constrained optimization.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">sig_0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">))</span>  <span class="c1"># Set initial guess</span>
        <span class="n">rho</span> <span class="o">=</span> <span class="mf">1.0</span>  <span class="c1"># Set initial penalty value</span>
        <span class="c1"># Set tolerance, very small values (i.e.,smaller than 10^-5) may cause</span>
        <span class="c1"># instabilities</span>
        <span class="n">epsilon</span> <span class="o">=</span> <span class="mi">10</span><span class="o">**-</span><span class="mi">5</span>
        <span class="c1"># Set inital beta values using beta function</span>
        <span class="n">Beta1</span><span class="p">,</span> <span class="n">Beta2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__betafcn</span><span class="p">(</span><span class="n">sig_0</span><span class="p">,</span> <span class="n">rho</span><span class="p">)</span>
        <span class="c1"># Initial search for minimum value using initial guess</span>
        <span class="n">sig_1</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__objfun_penalty</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">sig_0</span><span class="p">,</span>
                           <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">Comp1_mean</span><span class="p">,</span> <span class="n">sigma_vals</span><span class="p">,</span> <span class="n">Beta1</span><span class="p">,</span> <span class="n">Beta2</span><span class="p">),</span> <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># While either the difference between iterations or the difference in</span>
        <span class="c1"># objective function evaluation is greater than the tolerance, continue</span>
        <span class="c1"># iterating</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">sig_1</span> <span class="o">-</span> <span class="n">sig_0</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">epsilon</span> <span class="ow">and</span>
               <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__objfun</span><span class="p">(</span><span class="n">sig_1</span><span class="p">,</span> <span class="n">Comp1_mean</span><span class="p">,</span> <span class="n">sigma_vals</span><span class="p">)</span> <span class="o">-</span>
                   <span class="bp">self</span><span class="o">.</span><span class="n">__objfun</span><span class="p">(</span><span class="n">sig_0</span><span class="p">,</span> <span class="n">Comp1_mean</span><span class="p">,</span> <span class="n">sigma_vals</span><span class="p">))</span> <span class="o">&gt;</span> <span class="n">epsilon</span><span class="p">):</span>
            <span class="n">sig_0</span> <span class="o">=</span> <span class="n">sig_1</span>
            <span class="c1"># Calculate penalties for this iteration</span>
            <span class="n">Beta1</span><span class="p">,</span> <span class="n">Beta2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__betafcn</span><span class="p">(</span><span class="n">sig_0</span><span class="p">,</span> <span class="n">rho</span><span class="p">)</span>
            <span class="c1"># Find a new minimum</span>
            <span class="n">sig_1</span> <span class="o">=</span> <span class="n">optim</span><span class="o">.</span><span class="n">fmin</span><span class="p">(</span><span class="n">func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">__objfun_penalty</span><span class="p">,</span> <span class="n">x0</span><span class="o">=</span><span class="n">sig_0</span><span class="p">,</span>
                               <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">Comp1_mean</span><span class="p">,</span> <span class="n">sigma_vals</span><span class="p">,</span> <span class="n">Beta1</span><span class="p">,</span> <span class="n">Beta2</span><span class="p">),</span> <span class="n">disp</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">rho</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">rho</span>  <span class="c1"># Increase penalization</span>
        <span class="n">sig_final</span> <span class="o">=</span> <span class="n">sig_1</span>
        <span class="k">return</span> <span class="n">sig_final</span></div>


<div class="viewcode-block" id="GaussianCopula"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.GaussianCopula">[docs]</a><span class="k">class</span> <span class="nc">GaussianCopula</span><span class="p">(</span><span class="n">EA</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buoy</span><span class="p">,</span> <span class="n">n_size</span><span class="o">=</span><span class="mf">40.</span><span class="p">,</span> <span class="n">bin_1_limit</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">bin_step</span><span class="o">=</span><span class="mf">0.25</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">            depth : int</span>
<span class="sd">                Depth at measurement point (m)</span>
<span class="sd">            buoy : NDBCData</span>
<span class="sd">                ESSC.Buoy Object</span>
<span class="sd">            n_size: float</span>
<span class="sd">                minimum bin size used for Copula contour methods</span>
<span class="sd">            bin_1_limit: float</span>
<span class="sd">                maximum value of Hs for the first bin</span>
<span class="sd">            bin_step: float</span>
<span class="sd">                overlap interval for each bin</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;Gaussian Copula&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span> <span class="o">=</span> <span class="n">buoy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_size</span> <span class="o">=</span> <span class="n">n_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span> <span class="o">=</span> <span class="n">bin_1_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span> <span class="o">=</span> <span class="n">bin_step</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.Hs_SampleCA = None</span>
<span class="c1">#        self.Hs_SampleFSS = None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.T_SampleCA = None</span>
<span class="c1">#        self.T_SampleFSS = None</span>

<span class="c1">#        self.Weight_points = None</span>

<span class="c1">#        self.coeff, self.shift, self.comp1_params, self.sigma_param, self.mu_param = self.__generateParams(size_bin)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EA__getCopulaParams</span><span class="p">(</span><span class="n">n_size</span><span class="p">,</span><span class="n">bin_1_limit</span><span class="p">,</span><span class="n">bin_step</span><span class="p">)</span>

<div class="viewcode-block" id="GaussianCopula.getContours"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.GaussianCopula.getContours">[docs]</a>    <span class="k">def</span> <span class="nf">getContours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_ss</span><span class="p">,</span> <span class="n">time_r</span><span class="p">,</span> <span class="n">nb_steps</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;WDRT Extreme Sea State Gaussian Copula Contour function</span>
<span class="sd">        This function calculates environmental contours of extreme sea states using</span>
<span class="sd">        a Gaussian copula and the inverse first-order reliability</span>
<span class="sd">        method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">        time_ss : float</span>
<span class="sd">            Sea state duration (hours) of measurements in input.</span>
<span class="sd">        time_r : np.array</span>
<span class="sd">            Desired return period (years) for calculation of environmental</span>
<span class="sd">            contour, can be a scalar or a vector.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space used for</span>
<span class="sd">            inverse FORM calculation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Hs_Return : np.array</span>
<span class="sd">            Calculated Hs values along the contour boundary following</span>
<span class="sd">            return to original input orientation.</span>
<span class="sd">        T_Return : np.array</span>
<span class="sd">           Calculated T values along the contour boundary following</span>
<span class="sd">           return to original input orientation.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To obtain the contours for a NDBC buoy::</span>
<span class="sd">            import numpy as np</span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            # Pull spectral data from NDBC website</span>
<span class="sd">            buoy = ESSC.buoy(&#39;46022&#39;)</span>
<span class="sd">            buoy.fetchFromWeb()</span>

<span class="sd">            # Declare required parameters</span>
<span class="sd">            depth = 391.4  # Depth at measurement point (m)</span>

<span class="sd">            # Create Environtmal Analysis object using above parameters</span>
<span class="sd">            Gauss46022 = ESSC.GaussianCopula(depth, buoy)</span>

<span class="sd">            # used for inverse FORM calculation</span>
<span class="sd">            Time_SS = 1.  # Sea state duration (hrs)</span>
<span class="sd">            Time_r = np.array([100])  # Return periods (yrs) of interest</span>

<span class="sd">            nb_steps = 1000.  # Enter discretization of the circle in the normal space</span>

<span class="sd">            # Contour generation example</span>
<span class="sd">            Hs_Return, T_Return = Gauss46022.getContours(Time_SS, Time_r, nb_steps)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_ss</span> <span class="o">=</span> <span class="n">time_ss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_r</span> <span class="o">=</span> <span class="n">time_r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span> <span class="o">=</span> <span class="n">nb_steps</span>

        <span class="n">p_f</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">365</span> <span class="o">*</span> <span class="p">(</span><span class="mi">24</span> <span class="o">/</span> <span class="n">time_ss</span><span class="p">)</span> <span class="o">*</span> <span class="n">time_r</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_f</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Reliability</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="n">nb_steps</span><span class="p">)</span>
        <span class="c1"># Vary U1, U2 along circle sqrt(U1^2+U2^2)=beta</span>
        <span class="n">U1</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">U2</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

        <span class="n">comp_1</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">exponweib</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">),</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="n">tau</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Calculate Kendall&#39;s tau</span>
        <span class="n">rho_gau</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">tau</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mf">2.</span><span class="p">)</span>

        <span class="n">z2_Gau</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">rho_gau</span><span class="o">**</span><span class="mf">2.</span><span class="p">)</span><span class="o">+</span><span class="n">rho_gau</span><span class="o">*</span><span class="n">U1</span><span class="p">);</span>
        <span class="n">comp_2_Gaussian</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">z2_Gau</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1">#lognormalinverse</span>

        <span class="n">Hs_Return</span> <span class="o">=</span> <span class="n">comp_1</span>
        <span class="n">T_Return</span> <span class="o">=</span> <span class="n">comp_2_Gaussian</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="n">Hs_Return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="n">T_Return</span>
        <span class="k">return</span> <span class="n">Hs_Return</span><span class="p">,</span> <span class="n">T_Return</span></div>

<div class="viewcode-block" id="GaussianCopula.getSamples"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.GaussianCopula.getSamples">[docs]</a>    <span class="k">def</span> <span class="nf">getSamples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="k">def</span> <span class="nf">_saveParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groupObj</span><span class="p">):</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;n_size&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_size</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;bin_1_limit&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;bin_step&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;para_dist_1&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;para_dist_2&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;mean_cond&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;std_cond&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span><span class="p">)</span></div>


<div class="viewcode-block" id="Rosenblatt"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.Rosenblatt">[docs]</a><span class="k">class</span> <span class="nc">Rosenblatt</span><span class="p">(</span><span class="n">EA</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buoy</span><span class="p">,</span> <span class="n">n_size</span><span class="o">=</span><span class="mf">40.</span><span class="p">,</span> <span class="n">bin_1_limit</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">bin_step</span><span class="o">=</span><span class="mf">0.25</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">            depth : int</span>
<span class="sd">                Depth at measurement point (m)</span>
<span class="sd">            buoy : NDBCData</span>
<span class="sd">                ESSC.Buoy Object</span>
<span class="sd">            n_size: float</span>
<span class="sd">                minimum bin size used for Copula contour methods</span>
<span class="sd">            bin_1_limit: float</span>
<span class="sd">                maximum value of Hs for the first bin</span>
<span class="sd">            bin_step: float</span>
<span class="sd">                overlap interval for each bin</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;Rosenblatt&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span> <span class="o">=</span> <span class="n">buoy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_size</span> <span class="o">=</span> <span class="n">n_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span> <span class="o">=</span> <span class="n">bin_1_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span> <span class="o">=</span> <span class="n">bin_step</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.Hs_SampleCA = None</span>
<span class="c1">#        self.Hs_SampleFSS = None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.T_SampleCA = None</span>
<span class="c1">#        self.T_SampleFSS = None</span>

<span class="c1">#        self.Weight_points = None</span>

<span class="c1">#        self.coeff, self.shift, self.comp1_params, self.sigma_param, self.mu_param = self.__generateParams(size_bin)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EA__getCopulaParams</span><span class="p">(</span><span class="n">n_size</span><span class="p">,</span><span class="n">bin_1_limit</span><span class="p">,</span><span class="n">bin_step</span><span class="p">)</span>

<div class="viewcode-block" id="Rosenblatt.getContours"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.Rosenblatt.getContours">[docs]</a>    <span class="k">def</span> <span class="nf">getContours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_ss</span><span class="p">,</span> <span class="n">time_r</span><span class="p">,</span> <span class="n">nb_steps</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;WDRT Extreme Sea State Rosenblatt Copula Contour function</span>
<span class="sd">        This function calculates environmental contours of extreme sea states using</span>
<span class="sd">        a Rosenblatt transformation and the inverse first-order reliability</span>
<span class="sd">        method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">        time_ss : float</span>
<span class="sd">            Sea state duration (hours) of measurements in input.</span>
<span class="sd">        time_r : np.array</span>
<span class="sd">            Desired return period (years) for calculation of environmental</span>
<span class="sd">            contour, can be a scalar or a vector.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space used for</span>
<span class="sd">            inverse FORM calculation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Hs_Return : np.array</span>
<span class="sd">            Calculated Hs values along the contour boundary following</span>
<span class="sd">            return to original input orientation.</span>
<span class="sd">        T_Return : np.array</span>
<span class="sd">           Calculated T values along the contour boundary following</span>
<span class="sd">           return to original input orientation.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To obtain the contours for a NDBC buoy::</span>
<span class="sd">            import numpy as np</span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            # Pull spectral data from NDBC website</span>
<span class="sd">            buoy = ESSC.buoy(&#39;46022&#39;)</span>
<span class="sd">            buoy.fetchFromWeb()</span>

<span class="sd">            # Declare required parameters</span>
<span class="sd">            depth = 391.4  # Depth at measurement point (m)</span>


<span class="sd">            # Create Environtmal Analysis object using above parameters</span>
<span class="sd">            Rosen46022 = ESSC.Rosenblatt(depth, buoy)</span>

<span class="sd">            # used for inverse FORM calculation</span>
<span class="sd">            Time_SS = 1.  # Sea state duration (hrs)</span>
<span class="sd">            Time_r = np.array([100])  # Return periods (yrs) of interest</span>

<span class="sd">            nb_steps = 1000.  # Enter discretization of the circle in the normal space</span>

<span class="sd">            # Contour generation example</span>
<span class="sd">            Hs_Return, T_Return = Rosen46022.getContours(Time_SS, Time_r, nb_steps)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_ss</span> <span class="o">=</span> <span class="n">time_ss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_r</span> <span class="o">=</span> <span class="n">time_r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span> <span class="o">=</span> <span class="n">nb_steps</span>

        <span class="n">p_f</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">365</span> <span class="o">*</span> <span class="p">(</span><span class="mi">24</span> <span class="o">/</span> <span class="n">time_ss</span><span class="p">)</span> <span class="o">*</span> <span class="n">time_r</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_f</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Reliability</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="n">nb_steps</span><span class="p">)</span>
        <span class="c1"># Vary U1, U2 along circle sqrt(U1^2+U2^2)=beta</span>
        <span class="n">U1</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">U2</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

        <span class="n">comp_1</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">exponweib</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">),</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="n">lamda_cond</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">comp_1</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">comp_1</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">*</span><span class="n">comp_1</span><span class="o">**</span><span class="mi">3</span>      <span class="c1"># mean of Ln(T) as a function of Hs</span>
        <span class="n">sigma_cond</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">comp_1</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">*</span><span class="n">comp_1</span><span class="o">**</span><span class="mi">2</span>                                <span class="c1"># Standard deviation of Ln(T) as a function of Hs</span>

        <span class="n">comp_2_Rosenblatt</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U2</span><span class="p">),</span><span class="n">s</span><span class="o">=</span><span class="n">sigma_cond</span><span class="p">,</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="n">lamda_cond</span><span class="p">))</span>  <span class="c1"># lognormal inverse</span>

        <span class="n">Hs_Return</span> <span class="o">=</span> <span class="n">comp_1</span>
        <span class="n">T_Return</span> <span class="o">=</span> <span class="n">comp_2_Rosenblatt</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="n">Hs_Return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="n">T_Return</span>
        <span class="k">return</span> <span class="n">Hs_Return</span><span class="p">,</span> <span class="n">T_Return</span></div>

<div class="viewcode-block" id="Rosenblatt.getSamples"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.Rosenblatt.getSamples">[docs]</a>    <span class="k">def</span> <span class="nf">getSamples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="k">def</span> <span class="nf">_saveParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groupObj</span><span class="p">):</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;n_size&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_size</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;bin_1_limit&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;bin_step&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;para_dist_1&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;para_dist_2&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;mean_cond&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;std_cond&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span><span class="p">)</span></div>


<div class="viewcode-block" id="ClaytonCopula"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.ClaytonCopula">[docs]</a><span class="k">class</span> <span class="nc">ClaytonCopula</span><span class="p">(</span><span class="n">EA</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buoy</span><span class="p">,</span> <span class="n">n_size</span><span class="o">=</span><span class="mf">40.</span><span class="p">,</span> <span class="n">bin_1_limit</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">bin_step</span><span class="o">=</span><span class="mf">0.25</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">            depth : int</span>
<span class="sd">                Depth at measurement point (m)</span>
<span class="sd">            buoy : NDBCData</span>
<span class="sd">                ESSC.Buoy Object</span>
<span class="sd">            n_size: float</span>
<span class="sd">                minimum bin size used for Copula contour methods</span>
<span class="sd">            bin_1_limit: float</span>
<span class="sd">                maximum value of Hs for the first bin</span>
<span class="sd">            bin_step: float</span>
<span class="sd">                overlap interval for each bin</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;Clayton Copula&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span> <span class="o">=</span> <span class="n">buoy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_size</span> <span class="o">=</span> <span class="n">n_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span> <span class="o">=</span> <span class="n">bin_1_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span> <span class="o">=</span> <span class="n">bin_step</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.Hs_SampleCA = None</span>
<span class="c1">#        self.Hs_SampleFSS = None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.T_SampleCA = None</span>
<span class="c1">#        self.T_SampleFSS = None</span>

<span class="c1">#        self.Weight_points = None</span>

<span class="c1">#        self.coeff, self.shift, self.comp1_params, self.sigma_param, self.mu_param = self.__generateParams(size_bin)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EA__getCopulaParams</span><span class="p">(</span><span class="n">n_size</span><span class="p">,</span><span class="n">bin_1_limit</span><span class="p">,</span><span class="n">bin_step</span><span class="p">)</span>

<div class="viewcode-block" id="ClaytonCopula.getContours"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.ClaytonCopula.getContours">[docs]</a>    <span class="k">def</span> <span class="nf">getContours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_ss</span><span class="p">,</span> <span class="n">time_r</span><span class="p">,</span> <span class="n">nb_steps</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;WDRT Extreme Sea State Clayton Copula Contour function</span>
<span class="sd">        This function calculates environmental contours of extreme sea states using</span>
<span class="sd">        a Clayton copula and the inverse first-order reliability</span>
<span class="sd">        method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">        time_ss : float</span>
<span class="sd">            Sea state duration (hours) of measurements in input.</span>
<span class="sd">        time_r : np.array</span>
<span class="sd">            Desired return period (years) for calculation of environmental</span>
<span class="sd">            contour, can be a scalar or a vector.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space used for</span>
<span class="sd">            inverse FORM calculation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Hs_Return : np.array</span>
<span class="sd">            Calculated Hs values along the contour boundary following</span>
<span class="sd">            return to original input orientation.</span>
<span class="sd">        T_Return : np.array</span>
<span class="sd">           Calculated T values along the contour boundary following</span>
<span class="sd">           return to original input orientation.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To obtain the contours for a NDBC buoy::</span>
<span class="sd">            import numpy as np</span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            # Pull spectral data from NDBC website</span>
<span class="sd">            buoy = ESSC.buoy(&#39;46022&#39;)</span>
<span class="sd">            buoy.fetchFromWeb()</span>

<span class="sd">            # Declare required parameters</span>
<span class="sd">            depth = 391.4  # Depth at measurement point (m)</span>


<span class="sd">            # Create Environtmal Analysis object using above parameters</span>
<span class="sd">            Clayton46022 = ESSC.ClaytonCopula(depth, buoy)</span>

<span class="sd">            # used for inverse FORM calculation</span>
<span class="sd">            Time_SS = 1.  # Sea state duration (hrs)</span>
<span class="sd">            Time_r = np.array([100])  # Return periods (yrs) of interest</span>

<span class="sd">            nb_steps = 1000.  # Enter discretization of the circle in the normal space</span>

<span class="sd">            # Contour generation example</span>
<span class="sd">            Hs_Return, T_Return = Clayton46022.getContours(Time_SS, Time_r, nb_steps)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_ss</span> <span class="o">=</span> <span class="n">time_ss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_r</span> <span class="o">=</span> <span class="n">time_r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span> <span class="o">=</span> <span class="n">nb_steps</span>

        <span class="n">p_f</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">365</span> <span class="o">*</span> <span class="p">(</span><span class="mi">24</span> <span class="o">/</span> <span class="n">time_ss</span><span class="p">)</span> <span class="o">*</span> <span class="n">time_r</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_f</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Reliability</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="n">nb_steps</span><span class="p">)</span>
        <span class="c1"># Vary U1, U2 along circle sqrt(U1^2+U2^2)=beta</span>
        <span class="n">U1</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">U2</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

        <span class="n">comp_1</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">exponweib</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">),</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="n">tau</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Calculate Kendall&#39;s tau</span>
        <span class="n">theta_clay</span> <span class="o">=</span> <span class="p">(</span><span class="mf">2.</span><span class="o">*</span><span class="n">tau</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">tau</span><span class="p">)</span>

        <span class="n">z2_Clay</span><span class="o">=</span><span class="p">((</span><span class="mf">1.</span><span class="o">-</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">theta_clay</span><span class="p">)</span><span class="o">+</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="n">theta_clay</span><span class="p">)</span><span class="o">/</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U2</span><span class="p">))</span><span class="o">**</span><span class="p">(</span><span class="n">theta_clay</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">+</span><span class="n">theta_clay</span><span class="p">)))</span><span class="o">**</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="o">/</span><span class="n">theta_clay</span><span class="p">)</span>
        <span class="n">comp_2_Clayton</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">z2_Clay</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="c1">#lognormalinverse</span>

        <span class="n">Hs_Return</span> <span class="o">=</span> <span class="n">comp_1</span>
        <span class="n">T_Return</span> <span class="o">=</span> <span class="n">comp_2_Clayton</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="n">Hs_Return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="n">T_Return</span>
        <span class="k">return</span> <span class="n">Hs_Return</span><span class="p">,</span> <span class="n">T_Return</span></div>

<div class="viewcode-block" id="ClaytonCopula.getSamples"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.ClaytonCopula.getSamples">[docs]</a>    <span class="k">def</span> <span class="nf">getSamples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="k">def</span> <span class="nf">_saveParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groupObj</span><span class="p">):</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;n_size&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_size</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;bin_1_limit&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;bin_step&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;para_dist_1&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;para_dist_2&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;mean_cond&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;std_cond&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span><span class="p">)</span></div>


<div class="viewcode-block" id="GumbelCopula"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.GumbelCopula">[docs]</a><span class="k">class</span> <span class="nc">GumbelCopula</span><span class="p">(</span><span class="n">EA</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buoy</span><span class="p">,</span> <span class="n">n_size</span><span class="o">=</span><span class="mf">40.</span><span class="p">,</span> <span class="n">bin_1_limit</span><span class="o">=</span><span class="mf">1.</span><span class="p">,</span> <span class="n">bin_step</span><span class="o">=</span><span class="mf">0.25</span><span class="p">,</span><span class="n">Ndata</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">            depth : int</span>
<span class="sd">                Depth at measurement point (m)</span>
<span class="sd">            buoy : NDBCData</span>
<span class="sd">                ESSC.Buoy Object</span>
<span class="sd">            n_size: float</span>
<span class="sd">                minimum bin size used for Copula contour methods</span>
<span class="sd">            bin_1_limit: float</span>
<span class="sd">                maximum value of Hs for the first bin</span>
<span class="sd">            bin_step: float</span>
<span class="sd">                overlap interval for each bin</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;Gumbel Copula&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buoy</span> <span class="o">=</span> <span class="n">buoy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">n_size</span> <span class="o">=</span> <span class="n">n_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span> <span class="o">=</span> <span class="n">bin_1_limit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span> <span class="o">=</span> <span class="n">bin_step</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.Hs_SampleCA = None</span>
<span class="c1">#        self.Hs_SampleFSS = None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="kc">None</span>
<span class="c1">#        self.T_SampleCA = None</span>
<span class="c1">#        self.T_SampleFSS = None</span>
<span class="c1">#        self.Weight_points = None</span>

<span class="c1">#        self.coeff, self.shift, self.comp1_params, self.sigma_param, self.mu_param = self.__generateParams(size_bin)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span> <span class="o">=</span> <span class="n">Ndata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_limit_2</span> <span class="o">=</span> <span class="mf">0.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_limit_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_EA__getCopulaParams</span><span class="p">(</span><span class="n">n_size</span><span class="p">,</span><span class="n">bin_1_limit</span><span class="p">,</span><span class="n">bin_step</span><span class="p">)</span>

<div class="viewcode-block" id="GumbelCopula.getContours"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.GumbelCopula.getContours">[docs]</a>    <span class="k">def</span> <span class="nf">getContours</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_ss</span><span class="p">,</span> <span class="n">time_r</span><span class="p">,</span> <span class="n">nb_steps</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;WDRT Extreme Sea State Gumbel Copula Contour function</span>
<span class="sd">        This function calculates environmental contours of extreme sea states using</span>
<span class="sd">        a Gumbel copula and the inverse first-order reliability</span>
<span class="sd">        method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">        time_ss : float</span>
<span class="sd">            Sea state duration (hours) of measurements in input.</span>
<span class="sd">        time_r : np.array</span>
<span class="sd">            Desired return period (years) for calculation of environmental</span>
<span class="sd">            contour, can be a scalar or a vector.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space used for</span>
<span class="sd">            inverse FORM calculation.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Hs_Return : np.array</span>
<span class="sd">            Calculated Hs values along the contour boundary following</span>
<span class="sd">            return to original input orientation.</span>
<span class="sd">        T_Return : np.array</span>
<span class="sd">           Calculated T values along the contour boundary following</span>
<span class="sd">           return to original input orientation.</span>
<span class="sd">        nb_steps : float</span>
<span class="sd">            Discretization of the circle in the normal space</span>

<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To obtain the contours for a NDBC buoy::</span>
<span class="sd">            import numpy as np</span>
<span class="sd">            import WDRT.ESSC as ESSC</span>
<span class="sd">            # Pull spectral data from NDBC website</span>
<span class="sd">            buoy = ESSC.buoy(&#39;46022&#39;)</span>
<span class="sd">            buoy.fetchFromWeb()</span>

<span class="sd">            # Declare required parameters</span>
<span class="sd">            depth = 391.4  # Depth at measurement point (m)</span>
<span class="sd">            size_bin = 250.  # Enter chosen bin size</span>

<span class="sd">            # Create Environtmal Analysis object using above parameters</span>
<span class="sd">            Gumbel46022 = ESSC.GumbelCopula(depth, size_bin, buoy)</span>

<span class="sd">            # used for inverse FORM calculation</span>
<span class="sd">            Time_SS = 1.  # Sea state duration (hrs)</span>
<span class="sd">            Time_r = np.array([100])  # Return periods (yrs) of interest</span>

<span class="sd">            nb_steps = 1000.  # Enter discretization of the circle in the normal space</span>

<span class="sd">            # Contour generation example</span>
<span class="sd">            Hs_Return, T_Return = Gumbel46022.getContours(Time_SS, Time_r, nb_steps)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_ss</span> <span class="o">=</span> <span class="n">time_ss</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time_r</span> <span class="o">=</span> <span class="n">time_r</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nb_steps</span> <span class="o">=</span> <span class="n">nb_steps</span>

        <span class="n">p_f</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="mi">365</span> <span class="o">*</span> <span class="p">(</span><span class="mi">24</span> <span class="o">/</span> <span class="n">time_ss</span><span class="p">)</span> <span class="o">*</span> <span class="n">time_r</span><span class="p">)</span>
        <span class="n">beta</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">ppf</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_f</span><span class="p">),</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># Reliability</span>
        <span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="n">nb_steps</span><span class="p">)</span>
        <span class="c1"># Vary U1, U2 along circle sqrt(U1^2+U2^2)=beta</span>
        <span class="n">U1</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">U2</span> <span class="o">=</span> <span class="n">beta</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span>

        <span class="n">comp_1</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">exponweib</span><span class="o">.</span><span class="n">ppf</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">),</span><span class="n">a</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">c</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">loc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="n">tau</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">kendalltau</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">Hs</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Calculate Kendall&#39;s tau</span>
        <span class="n">theta_gum</span> <span class="o">=</span> <span class="mf">1.</span><span class="o">/</span><span class="p">(</span><span class="mf">1.</span><span class="o">-</span><span class="n">tau</span><span class="p">)</span>

        <span class="n">fi_u1</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U1</span><span class="p">);</span>
        <span class="n">fi_u2</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">U2</span><span class="p">);</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_limit_2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">max_limit_2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span><span class="p">)</span>
        <span class="n">z2</span> <span class="o">=</span> <span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="o">.</span><span class="n">cdf</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">scale</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

        <span class="n">comp_2_Gumb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">nb_steps</span><span class="p">)):</span>
            <span class="n">z1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">fi_u1</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">fi_u1</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span><span class="p">)</span>
            <span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">z1</span><span class="p">,</span><span class="n">z2</span><span class="p">))</span>
            <span class="n">Y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__gumbelCopula</span><span class="p">(</span><span class="n">Z</span><span class="p">,</span> <span class="n">theta_gum</span><span class="p">)</span> <span class="c1"># Copula density function</span>
            <span class="n">Y</span> <span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan_to_num</span><span class="p">(</span><span class="n">Y</span><span class="p">)</span>
            <span class="n">p_x2_x1</span> <span class="o">=</span> <span class="n">Y</span><span class="o">*</span><span class="p">(</span><span class="n">stats</span><span class="o">.</span><span class="n">lognorm</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">loc</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span> <span class="c1"># pdf 2|1, f(comp_2|comp_1)=c(z1,z2)*f(comp_2)</span>
            <span class="n">dum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">p_x2_x1</span><span class="p">)</span>
            <span class="n">cdf</span> <span class="o">=</span> <span class="n">dum</span><span class="o">/</span><span class="p">(</span><span class="n">dum</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># Estimate CDF from PDF</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">x2</span><span class="p">,</span> <span class="n">cdf</span><span class="p">))</span> <span class="c1"># Result of conditional CDF derived based on Gumbel copula</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">T</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">fi_u2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">table</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">comp_2_Gumb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">table</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">fi_u2</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">table</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">comp_2_Gumb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">table</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">table</span><span class="p">[</span><span class="n">j</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">comp_2_Gumb</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">table</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="n">Hs_Return</span> <span class="o">=</span> <span class="n">comp_1</span>
        <span class="n">T_Return</span> <span class="o">=</span> <span class="n">comp_2_Gumb</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">Hs_ReturnContours</span> <span class="o">=</span> <span class="n">Hs_Return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T_ReturnContours</span> <span class="o">=</span> <span class="n">T_Return</span>
        <span class="k">return</span> <span class="n">Hs_Return</span><span class="p">,</span> <span class="n">T_Return</span></div>

<div class="viewcode-block" id="GumbelCopula.getSamples"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.GumbelCopula.getSamples">[docs]</a>    <span class="k">def</span> <span class="nf">getSamples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

    <span class="k">def</span> <span class="nf">_saveParams</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">groupObj</span><span class="p">):</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Ndata&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Ndata</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;min_limit_2&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">min_limit_2</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;max_limit_2&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">max_limit_2</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;n_size&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">n_size</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;bin_1_limit&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_1_limit</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;bin_step&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bin_step</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;para_dist_1&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_1</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;para_dist_2&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">para_dist_2</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;mean_cond&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mean_cond</span><span class="p">)</span>
        <span class="n">groupObj</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;std_cond&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">std_cond</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__gumbelCopula</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">alpha</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39; Calculates the Gumbel copula density</span>
<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        u: np.array</span>
<span class="sd">                    Vector of equally spaced points between 0 and twice the</span>
<span class="sd">                    maximum value of T.</span>
<span class="sd">       alpha: float</span>
<span class="sd">                    Copula parameter. Must be greater than or equal to 1.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">       y: np.array</span>
<span class="sd">                   Copula density function.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">v</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">vmin</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">vmax</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">nlogC</span> <span class="o">=</span> <span class="n">vmax</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">vmin</span> <span class="o">/</span> <span class="n">vmax</span><span class="p">)</span> <span class="o">**</span> <span class="n">alpha</span><span class="p">)</span> <span class="o">**</span> <span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">alpha</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span><span class="n">nlogC</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">nlogC</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">alpha</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">+</span><span class="n">v</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="mi">2</span><span class="o">*</span><span class="n">alpha</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">nlogC</span><span class="p">))</span>
        <span class="k">return</span><span class="p">(</span><span class="n">y</span><span class="p">)</span></div>


<div class="viewcode-block" id="Buoy"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.Buoy">[docs]</a><span class="k">class</span> <span class="nc">Buoy</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Attributes</span>
<span class="sd">    __________</span>
<span class="sd">    swdList : list</span>
<span class="sd">        List that contains numpy arrays of the spectral wave density data,</span>
<span class="sd">        separated by year.</span>
<span class="sd">    freqList: list</span>
<span class="sd">        List that contains numpy arrays that contain the frequency values</span>
<span class="sd">        for each year</span>
<span class="sd">    dateList : list</span>
<span class="sd">        List that contains numpy arrays of the date values for each line of</span>
<span class="sd">        spectral data, separated by year</span>
<span class="sd">    Hs : list</span>
<span class="sd">        Significant wave height.</span>
<span class="sd">    T : list</span>
<span class="sd">        Energy period.</span>
<span class="sd">    dateNum : list</span>
<span class="sd">        List of datetime objects.</span>
<span class="sd">    &#39;&#39;&#39;</span>



    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">buoyNum</span><span class="p">,</span> <span class="n">savePath</span> <span class="o">=</span> <span class="s1">&#39;./Data/&#39;</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Parameters</span>
<span class="sd">        ___________</span>
<span class="sd">            buoyNum : string</span>
<span class="sd">                device number for desired buoy</span>
<span class="sd">            savePath : string</span>
<span class="sd">                relative path where the data read from ndbc.noaa.gov will be stored</span>


<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">swdList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">freqList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dateList</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dateNum</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span> <span class="o">=</span> <span class="n">buoyNum</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">savePath</span> <span class="o">=</span> <span class="n">savePath</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">savePath</span><span class="p">):</span>
          <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">savePath</span><span class="p">)</span>



<div class="viewcode-block" id="Buoy.fetchFromWeb"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.Buoy.fetchFromWeb">[docs]</a>    <span class="k">def</span> <span class="nf">fetchFromWeb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">saveType</span><span class="o">=</span><span class="s2">&quot;txt&quot;</span><span class="p">,</span> <span class="n">savePath</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="sd">&#39;&#39;&#39;Searches ndbc.noaa.gov for the historical spectral wave density</span>
<span class="sd">        data of a given device and writes the annual files from the website</span>
<span class="sd">        to a single .txt file, and stores the values in the swdList, freqList,</span>
<span class="sd">        and dateList member variables.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        saveType: string</span>
<span class="sd">            If set to to &quot;h5&quot;, the data will be saved in a compressed .h5</span>
<span class="sd">            file</span>
<span class="sd">            If set to &quot;txt&quot;, the data will be stored in a raw .txt file</span>
<span class="sd">            Otherwise, a file will not be created</span>
<span class="sd">        savePath : string</span>
<span class="sd">            Relative path to place directory with data files.</span>
<span class="sd">        Example</span>
<span class="sd">        _________</span>
<span class="sd">        &gt;&gt;&gt; import WDRT.ESSC as ESSC</span>
<span class="sd">        &gt;&gt;&gt; buoy = ESSC.Buoy(46022)</span>
<span class="sd">        &gt;&gt;&gt; buoy.fetchFromWeb()</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">numLines</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">numCols</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">numDates</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">dateVals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spectralVals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">savePath</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">savePath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">savePath</span>

        <span class="n">url</span> <span class="o">=</span> <span class="s2">&quot;http://www.ndbc.noaa.gov/station_history.php?station=</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">)</span>
        <span class="n">ndbcURL</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span><span class="n">proxies</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;http&quot;</span><span class="p">:</span><span class="s2">&quot;http://wwwproxy.sandia.gov:80&quot;</span><span class="p">})</span>
        <span class="n">ndbcURL</span><span class="o">.</span><span class="n">raise_for_status</span><span class="p">()</span>
        <span class="n">ndbcHTML</span> <span class="o">=</span> <span class="n">bs4</span><span class="o">.</span><span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">ndbcURL</span><span class="o">.</span><span class="n">text</span><span class="p">,</span> <span class="s2">&quot;lxml&quot;</span><span class="p">)</span>
        <span class="n">headers</span> <span class="o">=</span> <span class="n">ndbcHTML</span><span class="o">.</span><span class="n">findAll</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="n">text</span><span class="o">=</span><span class="s2">&quot;Spectral wave density data: &quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">headers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Spectral wave density data for given buoy not found&quot;</span><span class="p">)</span>


        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">headers</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">headers</span> <span class="o">=</span> <span class="n">headers</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">headers</span> <span class="o">=</span> <span class="n">headers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">links</span> <span class="o">=</span> <span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="s2">&quot;href&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">headers</span><span class="o">.</span><span class="n">find_next_siblings</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">href</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>

        <span class="k">if</span><span class="p">(</span><span class="n">saveType</span> <span class="ow">is</span> <span class="s1">&#39;txt&#39;</span><span class="p">):</span>
            <span class="c1"># Grab the device number so the filename is more specific</span>
            <span class="n">saveDir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">savePath</span><span class="p">,</span> <span class="s1">&#39;NDBC</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">))</span>
            <span class="nb">print</span> <span class="s2">&quot;Saving in :&quot;</span><span class="p">,</span> <span class="n">saveDir</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">saveDir</span><span class="p">):</span>
                <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">saveDir</span><span class="p">)</span>

        <span class="k">if</span><span class="p">(</span><span class="n">saveType</span> <span class="ow">is</span> <span class="s2">&quot;h5&quot;</span><span class="p">):</span>
            <span class="n">saveDir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">savePath</span><span class="p">,</span> <span class="s1">&#39;NDBC</span><span class="si">%s</span><span class="s1">-raw.h5&#39;</span> <span class="o">%</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">))</span>
            <span class="nb">print</span> <span class="s2">&quot;Saving in :&quot;</span><span class="p">,</span> <span class="n">saveDir</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">saveDir</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">link</span> <span class="ow">in</span> <span class="n">links</span><span class="p">:</span>
            <span class="n">dataLink</span> <span class="o">=</span> <span class="s2">&quot;http://ndbc.noaa.gov&quot;</span> <span class="o">+</span> <span class="n">link</span>
            <span class="n">year</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s2">&quot;[0-9]+&quot;</span><span class="p">,</span> <span class="n">link</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span><span class="p">(</span><span class="n">saveType</span> <span class="ow">is</span> <span class="s1">&#39;txt&#39;</span><span class="p">):</span>
            <span class="c1">#certain years have multiple files marked with the letter &#39;b&#39;</span>
                <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">))</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">link</span><span class="p">:</span>
                    <span class="n">swdFile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">saveDir</span><span class="p">,</span> <span class="s2">&quot;SWD-</span><span class="si">%s</span><span class="s2">-</span><span class="si">%d</span><span class="s2">.txt&quot;</span> <span class="o">%</span>
                                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">,</span> <span class="n">year</span><span class="p">)),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">swdFile</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">saveDir</span><span class="p">,</span> <span class="s2">&quot;SWD-</span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">.txt&quot;</span> <span class="o">%</span>
                                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;b&#39;</span><span class="p">)),</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>

            <span class="k">if</span><span class="p">(</span><span class="n">saveType</span> <span class="ow">is</span> <span class="s1">&#39;h5&#39;</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;b&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">))</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">link</span><span class="p">:</span>
                    <span class="n">dataSetName</span> <span class="o">=</span> <span class="nb">str</span><span class="p">((</span><span class="s2">&quot;SWD-</span><span class="si">%s</span><span class="s2">-</span><span class="si">%d</span><span class="s2">&quot;</span> <span class="o">%</span>
                                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">,</span> <span class="n">year</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">dataSetName</span> <span class="o">=</span> <span class="nb">str</span><span class="p">((</span><span class="s2">&quot;SWD-</span><span class="si">%s</span><span class="s2">-</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                   <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">year</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;b&#39;</span><span class="p">)))</span>


            <span class="n">fileName</span> <span class="o">=</span> <span class="n">dataLink</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;download_data&#39;</span><span class="p">,</span> <span class="s1">&#39;view_text_file&#39;</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">urllib2</span><span class="o">.</span><span class="n">urlopen</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
            <span class="nb">print</span> <span class="s2">&quot;Reading from:&quot;</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">geturl</span><span class="p">()</span>



            <span class="c1"># dates after 2004 contain a time-value for minutes</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">year</span> <span class="o">&gt;</span> <span class="mi">2004</span><span class="p">):</span>
                <span class="n">numDates</span> <span class="o">=</span> <span class="mi">5</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">numDates</span> <span class="o">=</span> <span class="mi">4</span>

            <span class="c1">#First Line of every file contains the frequency data</span>
            <span class="n">frequency</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">saveType</span> <span class="ow">is</span> <span class="s2">&quot;txt&quot;</span><span class="p">):</span>
                <span class="n">swdFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>
            <span class="n">frequency</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">frequency</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="n">numDates</span><span class="p">:],</span> <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>


            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">data</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">saveType</span> <span class="ow">is</span> <span class="s2">&quot;txt&quot;</span><span class="p">):</span>
                    <span class="n">swdFile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="n">currentLine</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">numCols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">currentLine</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">currentLine</span><span class="p">[</span><span class="n">numDates</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">999</span><span class="p">:</span>
                    <span class="n">numLines</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numDates</span><span class="p">):</span>
                        <span class="n">dateVals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentLine</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCols</span> <span class="o">-</span> <span class="n">numDates</span><span class="p">):</span>
                        <span class="n">spectralVals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentLine</span><span class="p">[</span><span class="n">j</span> <span class="o">+</span> <span class="n">numDates</span><span class="p">])</span>

            <span class="n">dateValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dateVals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
            <span class="n">spectralValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spectralVals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

            <span class="n">dateValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dateValues</span><span class="p">,</span> <span class="p">(</span><span class="n">numLines</span><span class="p">,</span> <span class="n">numDates</span><span class="p">))</span>
            <span class="n">spectralValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">spectralValues</span><span class="p">,</span> <span class="p">(</span><span class="n">numLines</span><span class="p">,</span>
                                                         <span class="p">(</span><span class="n">numCols</span> <span class="o">-</span> <span class="n">numDates</span><span class="p">)))</span>

            <span class="k">if</span><span class="p">(</span><span class="n">saveType</span> <span class="ow">is</span> <span class="s2">&quot;h5&quot;</span><span class="p">):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">dataSetName</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;-date_values&quot;</span><span class="p">,</span> <span class="n">data</span> <span class="o">=</span> <span class="n">dateValues</span><span class="p">,</span><span class="n">compression</span> <span class="o">=</span> <span class="s2">&quot;gzip&quot;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">dataSetName</span> <span class="o">+</span> <span class="s2">&quot;-frequency&quot;</span><span class="p">),</span><span class="n">data</span><span class="o">=</span><span class="n">frequency</span><span class="p">,</span><span class="n">compression</span> <span class="o">=</span> <span class="s2">&quot;gzip&quot;</span><span class="p">)</span>
                <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dataSetName</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="n">spectralValues</span><span class="p">,</span><span class="n">compression</span> <span class="o">=</span> <span class="s2">&quot;gzip&quot;</span><span class="p">)</span>

            <span class="k">del</span> <span class="n">dateVals</span><span class="p">[:]</span>
            <span class="k">del</span> <span class="n">spectralVals</span><span class="p">[:]</span>

            <span class="n">numLines</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">numCols</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">swdList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spectralValues</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">freqList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dateList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dateValues</span><span class="p">)</span>

            <span class="k">if</span><span class="p">(</span><span class="n">saveType</span> <span class="ow">is</span> <span class="s2">&quot;txt&quot;</span><span class="p">):</span>
                <span class="n">swdFile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepData</span><span class="p">()</span></div>

<div class="viewcode-block" id="Buoy.loadFromText"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.Buoy.loadFromText">[docs]</a>    <span class="k">def</span> <span class="nf">loadFromText</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dirPath</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Loads NDBC data previously downloaded to a series of text files in the</span>
<span class="sd">        specified directory.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            dirPath : string</span>
<span class="sd">                Relative path to directory containing NDBC text files (created by</span>
<span class="sd">                NBDCdata.fetchFromWeb). If left blank, the method will search</span>
<span class="sd">                all directories for the data using the current directory as</span>
<span class="sd">                the root.</span>


<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To load data from previously downloaded files</span>

<span class="sd">        &gt;&gt;&gt; import WDRT.ESSC as ESSC</span>
<span class="sd">        &gt;&gt;&gt; buoy = ESSC.buoy(46022)</span>
<span class="sd">        &gt;&gt;&gt; buoy.loadFromText(&#39;./Data/NDBC460022&#39;)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">dateVals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spectralVals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">numLines</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">dirPath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dirpath</span><span class="p">,</span> <span class="n">subdirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">dirs</span> <span class="ow">in</span> <span class="n">subdirs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;NDBC</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">)</span> <span class="ow">in</span> <span class="n">dirs</span><span class="p">:</span>
                        <span class="n">dirPath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirpath</span><span class="p">,</span><span class="n">dirs</span><span class="p">)</span>
                        <span class="k">break</span>
        <span class="k">if</span> <span class="n">dirPath</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Could not find directory containing NDBC data&quot;</span><span class="p">)</span>

        <span class="n">fileList</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">dirPath</span><span class="p">,</span><span class="s1">&#39;SWD*.txt&#39;</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">fileList</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;No NDBC data files found in &quot;</span> <span class="o">+</span> <span class="n">dirPath</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">fileName</span> <span class="ow">in</span> <span class="n">fileList</span><span class="p">:</span>
            <span class="nb">print</span> <span class="s1">&#39;Reading from: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
            <span class="n">frequency</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">numCols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">frequency</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;mm&#39;</span><span class="p">:</span>
                <span class="n">frequency</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">frequency</span><span class="p">[</span><span class="mi">5</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
                <span class="n">numTimeVals</span> <span class="o">=</span> <span class="mi">5</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">frequency</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">frequency</span><span class="p">[</span><span class="mi">4</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
                <span class="n">numTimeVals</span> <span class="o">=</span> <span class="mi">4</span>

            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">currentLine</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">currentLine</span><span class="p">[</span><span class="n">numTimeVals</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">999</span><span class="p">:</span>
                    <span class="n">numLines</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numTimeVals</span><span class="p">):</span>
                        <span class="n">dateVals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentLine</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">numCols</span> <span class="o">-</span> <span class="n">numTimeVals</span><span class="p">):</span>
                        <span class="n">spectralVals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">currentLine</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="n">numTimeVals</span><span class="p">])</span>

            <span class="n">dateValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dateVals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int</span><span class="p">)</span>
            <span class="n">spectralValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">spectralVals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">double</span><span class="p">)</span>
            <span class="n">dateValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">dateValues</span><span class="p">,</span> <span class="p">(</span><span class="n">numLines</span><span class="p">,</span> <span class="n">numTimeVals</span><span class="p">))</span>
            <span class="n">spectralValues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                <span class="n">spectralValues</span><span class="p">,</span> <span class="p">(</span><span class="n">numLines</span><span class="p">,</span> <span class="p">(</span><span class="n">numCols</span> <span class="o">-</span> <span class="n">numTimeVals</span><span class="p">)))</span>

            <span class="k">del</span> <span class="n">dateVals</span><span class="p">[:]</span>
            <span class="k">del</span> <span class="n">spectralVals</span><span class="p">[:]</span>

            <span class="n">numLines</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">numCols</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">swdList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spectralValues</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">freqList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dateList</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dateValues</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepData</span><span class="p">()</span></div>

<div class="viewcode-block" id="Buoy.loadFromH5"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.Buoy.loadFromH5">[docs]</a>    <span class="k">def</span> <span class="nf">loadFromH5</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileName</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads NDBCdata previously saved in a .h5 file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            fileName : string</span>
<span class="sd">                Name of the .h5 file to load data from.</span>
<span class="sd">        Example</span>
<span class="sd">        -------</span>
<span class="sd">        To load data from previously downloaded files</span>

<span class="sd">        &gt;&gt;&gt; import WDRT.ESSC as ESSC</span>
<span class="sd">        &gt;&gt;&gt; buoy = ESSC.Buoy(46022)</span>
<span class="sd">        &gt;&gt;&gt; buoy.loadFromH5(&quot;./Data&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">file_extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">file_extension</span><span class="p">:</span>
            <span class="n">fileName</span> <span class="o">=</span> <span class="n">fileName</span> <span class="o">+</span> <span class="s1">&#39;.h5&#39;</span>
        <span class="nb">print</span> <span class="s2">&quot;Reading from: &quot;</span><span class="p">,</span> <span class="n">fileName</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">IOError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">IOError</span><span class="p">(</span><span class="s2">&quot;Could not find file: &quot;</span> <span class="o">+</span> <span class="n">fileName</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;buoy_Data/Hs&#39;</span><span class="p">][:])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;buoy_Data/Te&#39;</span><span class="p">][:])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dateNum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;buoy_Data/dateNum&#39;</span><span class="p">][:])</span>
        <span class="nb">print</span> <span class="s2">&quot;----&gt; SUCCESS&quot;</span></div>

<div class="viewcode-block" id="Buoy.saveData"><a class="viewcode-back" href="../../modules.html#WDRT.ESSC.Buoy.saveData">[docs]</a>    <span class="k">def</span> <span class="nf">saveData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileName</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Saves NDBCdata to hdf5 file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            savePath : string</span>
<span class="sd">                Relative path for desired file.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fileName</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">fileName</span> <span class="o">=</span> <span class="s1">&#39;NDBC&#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">buoy</span><span class="o">.</span><span class="n">buoyNum</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;.h5&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">file_extension</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">fileName</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">file_extension</span><span class="p">:</span>
                <span class="n">fileName</span> <span class="o">=</span> <span class="n">fileName</span> <span class="o">+</span> <span class="s1">&#39;.h5&#39;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">fileName</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_saveData</span><span class="p">(</span><span class="n">f</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_saveData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileObj</span><span class="p">):</span>
        <span class="k">if</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Hs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">gbd</span> <span class="o">=</span> <span class="n">fileObj</span><span class="o">.</span><span class="n">create_group</span><span class="p">(</span><span class="s1">&#39;buoy_Data&#39;</span><span class="p">)</span>
            <span class="n">f_Hs</span> <span class="o">=</span> <span class="n">gbd</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Hs&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">Hs</span><span class="p">)</span>
            <span class="n">f_Hs</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;m&#39;</span>
            <span class="n">f_Hs</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;significant wave height&#39;</span>
            <span class="n">f_T</span> <span class="o">=</span> <span class="n">gbd</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;Te&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
            <span class="n">f_T</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;units&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;m&#39;</span>
            <span class="n">f_T</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;energy period&#39;</span>
            <span class="n">f_dateNum</span> <span class="o">=</span> <span class="n">gbd</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="s1">&#39;dateNum&#39;</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dateNum</span><span class="p">)</span>
            <span class="n">f_dateNum</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;description&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;datenum&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Buoy object contains no data&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_prepData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Runs _getStats and _getDataNums for full set of data, then removes any</span>
<span class="sd">        NaNs.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">swdList</span><span class="p">)</span>
        <span class="n">Hs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">T</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dateNum</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">tmp1</span><span class="p">,</span> <span class="n">tmp2</span> <span class="o">=</span> <span class="n">_getStats</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">swdList</span><span class="p">[</span><span class="n">ii</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">freqList</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span>
            <span class="n">Hs</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tmp1</span><span class="p">)</span>
            <span class="n">T</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">tmp2</span><span class="p">)</span>
            <span class="n">dateNum</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_getDateNums</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dateList</span><span class="p">[</span><span class="n">ii</span><span class="p">]))</span>
        <span class="n">Hs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Hs</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        <span class="n">dateNum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dateNum</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>

        <span class="c1"># Removing NaN data, assigning T label depending on input (Te or Tp)</span>
        <span class="n">Nanrem</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">|</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">Hs</span><span class="p">))</span>
        <span class="c1"># Find NaN data in Hs or T</span>
        <span class="n">dateNum</span> <span class="o">=</span> <span class="n">dateNum</span><span class="p">[</span><span class="n">Nanrem</span><span class="p">]</span>  <span class="c1"># Remove any NaN data from DateNum</span>
        <span class="n">Hs</span> <span class="o">=</span> <span class="n">Hs</span><span class="p">[</span><span class="n">Nanrem</span><span class="p">]</span>  <span class="c1"># Remove any NaN data from Hs</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">Nanrem</span><span class="p">]</span>  <span class="c1"># Remove any NaN data from T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Hs</span> <span class="o">=</span> <span class="n">Hs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">T</span> <span class="o">=</span> <span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dateNum</span> <span class="o">=</span> <span class="n">dateNum</span>
        <span class="k">return</span> <span class="n">Hs</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">dateNum</span></div>

<span class="k">def</span> <span class="nf">_getDateNums</span><span class="p">(</span><span class="n">dateArr</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;datetime objects</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">        dateArr : np.array</span>
<span class="sd">            Array of a specific years date vals from NDBC.fetchFromWeb</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">        dateNum : np.array</span>
<span class="sd">            Array of datetime objects.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">dateNum</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">times</span> <span class="ow">in</span> <span class="n">dateArr</span><span class="p">:</span>
        <span class="k">if</span>  <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">1900</span><span class="p">:</span>
            <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1900</span> <span class="o">+</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">2005</span><span class="p">:</span>
            <span class="n">dateNum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">date</span><span class="o">.</span><span class="n">toordinal</span><span class="p">(</span><span class="n">datetime</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                   <span class="n">times</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="mi">3</span><span class="p">])))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dateNum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">date</span><span class="o">.</span><span class="n">toordinal</span><span class="p">(</span><span class="n">datetime</span><span class="p">(</span><span class="n">times</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                                   <span class="n">times</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">times</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span>
                                                   <span class="n">times</span><span class="p">[</span><span class="mi">4</span><span class="p">])))</span>
    <span class="k">return</span> <span class="n">dateNum</span>

<span class="k">def</span> <span class="nf">_getStats</span><span class="p">(</span><span class="n">swdArr</span><span class="p">,</span> <span class="n">freqArr</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;Significant wave height and energy period</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">            swdArr : np.array</span>
<span class="sd">                Numpy array of the spectral wave density data for a specific year</span>
<span class="sd">            freqArr: np.array</span>
<span class="sd">                Numpy array that contains the frequency values for a specific year</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">            Hm0 : list</span>
<span class="sd">                Significant wave height.</span>
<span class="sd">            Te : list</span>
<span class="sd">                Energy period.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">Hm0</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">T</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">swdArr</span><span class="p">:</span>
            <span class="n">m_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">line</span> <span class="o">*</span> <span class="n">freqArr</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">freqArr</span><span class="p">)</span>
            <span class="n">m0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">freqArr</span><span class="p">)</span>
            <span class="n">Hm0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mf">4.004</span> <span class="o">*</span> <span class="n">m0</span> <span class="o">**</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
            <span class="n">T</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">m_1</span> <span class="o">/</span> <span class="n">m0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Hm0</span><span class="p">,</span> <span class="n">T</span>
</pre></div>

           </div>
           <div class="articleComments">
            
           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, Sandia National Laboratories and The National Renewable Energy Laboratory.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true,
            SOURCELINK_SUFFIX: '.txt'
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>
      <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>